Special Member Functionlarýn en önemli özelliði, belirli þartlar oluþtuðunda kodlarý örtülü olarak derleyici tarafýndan yazýlabiliyor.			
////////////////////////////////////////////////////////////////////////////////////////////

													COPY CONSTRUCTOR
1-) Baþka bir sýnýf nesnesinin deðerini kullanarak bir sýnýf nesnesinin kopyalanma yoluyla hayata gelmesi.
		Ya da bir nesneye baþka bir nesnenin deðerini atýyoruz. Bu durumda 2 sonuç doðuyor.
		1- Bu nesneler birbirinden baðýmsýz yani bundan sonraki bu nesnelerin biri üzerinde yapýlan iþlemler diðerini etkilemeyecek.
		2- Bu nesneler karþýlaþtýrýlabilir nesneler ise(equality comparable) bu nesneler eþit olacak yani true deðer verecek. 

class Myclass{};
int main(void){
	Myclass m1;
	Myclass m2(m1); // burada m2 sýnýf nesnesi hayata m1'in state'i, deðeri ne ise m2 de öyle olsun diyoruz. Copy constructor çaðýrýlacak 
}

Rule Of Zero: Eðer gereklilik yok ise sýnýfýn special member functionlarýnýn derleyici tarafýndan yazýlmasýna izin verilmesi gerektiðini
	anlatan kural. Constructorlarý kendimiz de yazabiliriz buna bir engel yok fakat eðer kendimiz yazýyor isek bunun gerekli olmasý gerek.
		Diðer türlü derleyici, dilin kurallarýna uyarak bizim için bu kodu yazýyor zaten.(Default ctor bu kuralýn hem dýþýnda hem de dahil)

2-) Derleyici tarafýndan örtülü olarak yazýlan copy constructor:
		-Public: Yani client kod tarafýndan çaðrýlabilir
		-Non static
		-Inline: Constructorun tanýmýný sýnýfýn içerisinde yapýyor. Bir .h dosyasýný include ettiðimiz zaman derleyicinin bu sýnýfýn
			constructorýnýn tanýmýný görüyor olarak düþünmemiz gerek.

3-) Yazýlan copy constructorýn;
		-Diðer constructorlarda olduðu gibi geri dönüþ deðeri yok. void bile yazamayýz
		-Constructorýn parametre deðiþkeni const ClassName&r türünden. Yani const L value reference türünden. Sonuçta o parametreye baþka sýnýf türünden
			nesnenin referansý verilecek ki kopyalama iþlemi yapýlabilsin.
			class Eng{
				public:
					Eng(const Eng&r);
			};
4-) Copy constructor sýnýfýn data memberlarýna kopyalama iþlemini, kopyalandýðý sýnýfýn data memberlarýnýn deðerlerinden alýr.
	A B C bir tür olmak üzere

class Myclass{
public: 
	Myclass(const Myclass &r) : ax(r.ax), bx(r.bx), cx(r.cx) {}
private:
	A ax;
	B bx;
	C cx;
	// ax,bx,cx öðeleri deðerlerini, kopyalandýklarý sýnýf nesnesinin tuttuðu deðerleri alarak hayata geldi.
};
////////////////////////////////////////////////////////////////////////////////////////////
												COPY CONSTRUCTOR KULLANIM ALANLARI
Copy constructor üç yerde kullanýlýyor. 
	1- Bir sýnýf türünden nesneden ayný sýnýf türünden baþka bir nesneye kopyalama yaparken.

#include <iostream>
class Date {
public:
	Date(int d, int m, int y) : md(d), mm(m), my(y) 
	{
		std::cout << "Date(int, int, int) constructor called this = " << this << '\n';
	}
	~Date() 
	{
		std::cout << "~Date() this = " << this << '\n';
	}
private:
	int md, mm, my;
};


int main() {
	Date d1(12, 4, 1998);
	Date d2(d1);
}
Yukarýdaki örnekte ekrana 1 adet constructordan 2 adette destructordan yazý yazýlacak. 1 tane yazýlmasýnýn sebebi d1'i default constructor ile
	hayata getirirken d2'nin kodu derleyici tarafýndan yazýlmýþ copy constructor ile olmasýndan dolayý. 

Date(int, int, int) constructor called this = 00000015818FF928
~Date() this = 00000015818FF958
~Date() this = 00000015818FF928

Aþaðýda copy constructorun kodunu da ekledim. Aradaki farký görebilmek için
#include <iostream>
class Date {
public:
	Date(const Date& d) : md(d.md), mm(d.mm), my(d.my) 
	{
		std::cout << "Date(const Date&) Copy constructor called this = " << this << '\n';
	}
	Date(int d, int m, int y) : md(d), mm(m), my(y) 
	{
		std::cout << "Date(int, int, int) constructor called this = " << this << '\n';
	}
	~Date() 
	{
		std::cout << "~Date() this = " << this << '\n';
	}
private:
	int md, mm, my;
};


int main() {
	Date d1(12, 4, 1998);
	Date d2(d1);
}
Date(int, int, int) constructor called this = 000000D5F2CFF678
Date(const Date&) Copy constructor called this = 000000D5F2CFF6A8
~Date() this = 000000D5F2CFF6A8
~Date() this = 000000D5F2CFF678


Bütün constructorlar, special member function olsun olmasýn overloaddur. Mesela yukarýda d1 için default ctor kullanýlýr iken
	d2 için copy constructor kullanýlýyor. 

////////////////////////////////////////////////////////////////////////////////////////////
2- Fonksiyon parametrelerinde sýnýf türünden bir nesneyi alýyorsa orada kullanýlýyor.

#include <iostream>
class Myclass {
public:
	Myclass() {
		std::cout << "Default ctor\n";
	}
	~Myclass() {
		std::cout << "Destructor\n";
	}
};

void func(Myclass m) {};

int main() {
	Myclass m1;
	func(m1);
}
Burada m1 öðesi, fonksiyonun parametre deðiþkeni olan m öðesine copy constructor ile kopyalanacak.
Copy constructorýn parametresi const L value reference olduðu için L value, R value, const veya const olmayan nesneleri alabiliyor.
	Derleyici bu ifadeler için arka planda bir deðiþken oluþturup orada tutuyor.
class Date {
public:
	Date(const Date& d) : md(d.md), mm(d.mm), my(d.my) 
	{
		std::cout << "Date(const Date&) Copy constructor called this = " << this << '\n';
	}
	~Date() 
	{
		std::cout << "~Date() this = " << this << '\n';
	}
private:
	int md, mm, my;
};

int main(){
	Date dx{4, 5, 2022};
	Date dy = Date{5, 6, 1995}; // Atama operatörünün saðýndaki ifade r value expression olmasýna raðmen
									// copy constructorýn const L value ref olmasýndan dolayý hiçbir problem olmadan kopyalama iþlemini yapýyor.
}
////////////////////////////////////////////////////////////////////////////////////////////
3- Bir fonksiyonun geri dönüþ deðerinin bir sýnýf türünden olmasý. Geri dönüþ deðerini tutacak nesne için copy constructor çaðýrýlacak.

class Myclass {};
Myclass g;
Myclass foo(){
	return g; 
}
////////////////////////////////////////////////////////////////////////////////////////////
												HANGI SENARYOLARDA COPY CONSTRUCTORU BÝZ YAZMALIYIZ?

1- Bazý sýnýflar kaynak(resources) kullanýyor. Dinamik olarak allocate edilmiþ bir bellek gibi. 
	Bu belleklere de bir handle(o adresi gösteren bir pointer/referans) olmak zorunda yoksa o belleðe eriþemeyiz. 
	Copy constructor ile kopyalama iþlevi yapýldýðýnda bütün deðerler ayný olacak. Buna handleda dahil. Yani bu demek oluyor ki kopyalanma iþleminin
		yapýldýðý sýnýf nesnesi üzerinden yapýlacak herhangi bir deðiþiklik orijinal öðeninde deðerini deðiþtirecek. Copy constructor için kopyalama iþleminden
			sonra iki öðeninde birbirinden baðýmsýz olduðunu söylemiþtik. Bu durumun önüne geçmek için copy constructorý kendimiz yazmamýz gerekiyor.

#include <iostream>
class String {
public:
	String(const char*);
private:
	char* mp; // yazýnýn adresinin tutulduðu handle
	std::size_t mlen; // yazýnýn boyutunun tutulduðu data member
};

int main() {
	String str("bugun sinifin ozel fonksiyonlarini isliyoruz");

	String str2 = str; // buradaki örnekte str öðesi str2ye kopyalanýyor. Handleda kopyalandýðý için str2 üzerinden belleðe eriþerek yaptýðým
						// her deðiþiklik str öðesini de etkiliyor burada.
}

String için gerekli alanýn ayrýlmasý için constructorda memory allocation iþlemini yaparken, bu sýnýfla iþimiz bittiðinde ayný þekilde
	allocate ettiðimiz belleði free etmemiz gerekiyor. Bunu da destructor içinde yapacaðýz. Buna RAII idiomu deniyor. 
Resource Acquisition Is Initialization(RAII)

Eðer copy constructorý derleyiciye yazdýrýp, destructor içerisinde bu belleðe free edersek, bu free edilmiþ bellek bloðunun kullanýlmasý
	tanýmsýz davranýþ oluþturacak.

class String {
public:
	String(const char*);
	~String()
	{
		if(mp)
			std::free(mp); 
	}
private:
	char* mp; // yazýnýn adresinin tutulduðu handle
	std::size_t mlen; // yazýnýn boyutunun tutulduðu data member
};
void func(String s){
	// burada copy construct ile member to member copy olacak. Fonksiyondan çýkýldýðýnda ise s için destruct çaðrýlacak.
	// s için destruct çaðrýldýðnýda mp free edileceðinden ve str nesnesi hala hayatta olduðundan dolayý mp artýk bir dangling pointer olacak.
}
						

int main(){
	String str("bugun sinifin ozel fonksiyonlarini isliyoruz");

	func(str);
}
Bunun önüne geçmek içinde copy constructoru kendimiz yazacaðýz. Kopyalama iþlemini yaparken yeni bir memory allocate edilecek ve kopyalama iþlemi
	o adrese yapýlacak. Handle ise bu adresi tutacak.

Member to member, yani kaynaktan gelen bütün bilgilerin öðe öðe kopyalanmasý, kaynaðýn tuttuðu adresi göstermesi gibi kopyalama iþleminin
	yapýlmasýna 'Shallow(sýð) Copy' veya Memberwise Copy deniyor. Yukarýdaki problemi açýklamak için bir terim bu. 
Kopyalama iþlemi yaparken ana kaynaðýn adreslerini tutmak yerine ona yeni adres allocate edilmesine ise 'Deep(derin) Copy' deniyor
	Bu iki terim de standart tarafýndan belirlenmiþ terimler deðil.
////////////////////////////////////////////////////////////////////////////////////////////
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdlib>
#include <cstring>
class String {
public:
	String(const char* p) : mlen(std::strlen(p))
	{
		mp = static_cast<char*>(std::malloc(mlen + 1));
		if (!mp) {
			std::cerr << ("cannot allocate memory\n");
			std::exit(EXIT_FAILURE);
		}
		strcpy(mp, p);
	}
	~String()
	{
		if (mp)
			std::free(mp);
	}
	std::size_t length()const
	{
		return mlen;
	}
	void print()const
	{
		std::cout << '[' << mp << ']' << '\n';
	}
private:
	std::size_t mlen; 
	char* mp; 
};
void foo(String s)
{
	std::cout << "foo cagrildi \n";
	s.print();
	(void)std::getchar();
}
int main() {
	String str("bugun sinifin ozel fonksiyonlarini isliyoruz");

	str.print();

	foo(str); // fonksiyonu çaðýrdýðýmýzda copy constructor ile beraber str nesnesinin tuttuðu yazýnýn adresi parametre deðiþkeni olan
				// s'ye kopyalanacak. 261. satýrdaki getchar input aldýðýnda fonksiyondan çýkýlmasýyla beraber s parametre deðiþkeni için destructor çaðrýlacak
				// ve strden gelen adres destructor içinde free edilece. str nesnesi halen hayatta olduðu için artýk dangling pointer tutuyor. 
				// program akýþýnýn sonuna geldiðinde str içinde destructor çaðrýlacak ve destructor bir dangling pointerý free etmeye çalýþacak.
				// Ýþte bu yüzden bu gibi durumlarýn önüne geçmek için copy constructorý kendimiz yazmamýz gerekiyor. 

	str.print();
}
 String (const String& other) : mlen(other.mlen), mp(other.mp) {} -> derleyicinin yazdýðý copy constructor böyle gözüküyor shallow/memberwise copy
////////////////////////////////////////////////////////////////////////////////////////////
Copy constructorda kod tekrarý yapýlýyor ama bu örnek için takma kafaya.
Ýlk olarak yazýnýn uzunluðu + 1(null karakteri) için bellek alaný allocate ediyoruz. Allocate edilen bu bellek alanýna
	referansýný aldýðýmýz sýnýf nesnesinin içerisindeki adreste tutulan yazýyý allocate ettiðimiz belleðe kopyalýyoruz.
	Bu sayede artýk yazý üstünde yaptýðýmýz deðiþiklikler kaynakta tutulan yazý veya bellek üzerinde deðiþiklik yapmýyor.
class String {
public:
	String(const String& other) : mlen(other.mlen) // eðer burada mlen'i MIL ile hayata getirmeseydik derleyici otomatik olarak default initialization yapacaktý
	{
		mp = static_cast<char*>(std::malloc(mlen + 1));
		if (!mp) {
			std::cerr << ("cannot allocate memory\n");
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mp, other.mp); // other.mp kopyalama iþlemi yaptýðýmýz sýnýf nesnesinden deðiþkenin referansýný kullanarak adreste tutulan yazýyý
									// yeni adrese kopyalýyoruz.
	}
	String(const char* p) : mlen(std::strlen(p))
	{
		mp = static_cast<char*>(std::malloc(mlen + 1));
		if (!mp) {
			std::cerr << ("cannot allocate memory\n");
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mp, p);
	}
	~String()
	{
		if (mp)
			std::free(mp);
	}
	std::size_t length()const
	{
		return mlen;
	}
	void print()const
	{
		std::cout << '[' << mp << ']' << '\n';
	}
private:
	std::size_t mlen; 
	char* mp; 
};


Copy constructorýn kodunun bizim tarafýmýzdan yazýlmasý oran olarak %1-2 falan. Yani her zaman copy constructorý biz yazýyoruz
	gibi bir algý olmasýn.
////////////////////////////////////////////////////////////////////////////////////////////
																	COPY ASSIGNMENT
yukarýdaki string sýnýfý kullanýlýyor bu örnekte
int main() {
	String str("bugun sinifin ozel fonksiyonlarini isliyoruz");

	str.print();
	if (str.length() > 10) {
		String sx("Ben blok icerisinde kullanilacak bir yaziyim");
		sx.print();
		sx = str; // burada yapýlan atama iþlemi operator overloadingden dolayý bir fonksiyon çaðrý iþlemi yapýyor.
					// operator overloading yapýlýrken operator keywordü ve operatörün kendisi gelir örneðinn -> operator=(param2) -> operator assign 
						// bu çaðrýlan fonksiyona assign operator function deniyor. Bu operator loading konusunu ileride görücez
					// bu yapýlan assignmenttan dolayý burada undefined behaviour var. Derleyici tarafýndan implicitly-declared olarak bir copy assignment
					// kodu yazýlýyor. 
		sx.print();
		(void)getchar();
	}
	str.print();
}
Sýnýfýn Copy assignment olmak zorunda. Olmazsa olmuyor. Ya biz yazýcaz ya da derleyici
Copy assignment'ýn constructorlardan farklý olarak geri dönüþ deðeri var. Döndürdüðü deðer L value reference
	Aldýðý parametre deðiþkeni ise const Myclass& 
	Constructor Initializator List copy assignment için kullanýlamaz.

class1.operator=(class2) ile class1 = class2 arasýnda hiçbir fark yok. Burada operator loadingten faydalanýlýyor.

class Myclass{
public: 
	Myclass(const Myclass &r) : ax(r.ax), bx(r.bx), cx(r.cx) {}
	Myclass& operator=(const Myclass& r){
		ax = r.ax;
		bx = r.bx;
		cx = r.cx;
		// ax, bx, cx elemanlarý eðer primitive türler ise direkt olarak kopyalama iþlemi olacak. Sýnýf türünden nesneler ise
			// shallow copy olacaðýndan dolayý resmen bire bir kopyalama yapýlacak. Bu da HANDLE sistemi üzerinde probleme yol açýyor. 
			// yukarýda var notu zaten bunun dangling pointere dönüþme olayý. 
			// Burada diðer sýnýf türlerinden kopyalama iþlemi için copy constructor deðil copy assignment çaðrýlacak.

		return *this; // Kopyalama iþleminin yapýldýðý sýnýfý döndürüyoruz
	}
private:
	A ax;
	B bx;
	C cx;
};

#include <iostream>
class Myclass {
public:
	Myclass& set(int);
	void print()const;
};
  
int main() {
	Myclass m1, m2;

	m1.operator=(m2).set(44).print();
	(m1 = m2).set(45).print();
	/*
		Yukarýdaki iki þeyde ayný anlama geliyor. Atama operatörünün geri dönüþ deðeri sýnýf türünden L value ref.
	*/
}

	
Copy constructorda hayata gelme iþlemi(initialization) yapýlýrken, copy assignmentta hali hazýrda hayatta olan nesneye atama iþlemi yapýlýr.
	Bundan dolayý copy assignment hem deep copy iþlemi(copy constructor) hem de resource release(destructor) iþlemini yapmak zorunda. 
	Ýlk olarak initialize edilmiþ bellek bloðunu free etmemiz gerek. Daha sonra da bellek bloðu allocate edilir ve kopyalama iþlemi yapýlrý. 
Aþaðýdaki kod, yukarýda copy assignment baþýnda verdiðimiz örnekte yaþanýlan problemi çözüyor. 

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdlib>
#include <cstring>
class String {
public:
	String& operator=(const String& other) 
	{
		mlen = other.length();
		std::free(mp);
		mp = static_cast<char*>(std::malloc(mlen + 1));
		if (!mp) {
			std::cerr << ("cannot allocate memory\n");
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mp, other.mp); 
		return *this;
	}
	String(const String& other) : mlen(other.mlen) // eðer burada mlen'i MIL ile hayata getirmeseydik derleyici otomatik olarak default initialization yapacaktý
	{
		mp = static_cast<char*>(std::malloc(mlen + 1));
		if (!mp) {
			std::cerr << ("cannot allocate memory\n");
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mp, other.mp); // other.mp kopyalama iþlemi yaptýðýmýz sýnýf nesnesinden deðiþkenin referansýný kullanarak adreste tutulan yazýyý
		// yeni adrese kopyalýyoruz.
	}
	String(const char* p) : mlen(std::strlen(p))
	{
		mp = static_cast<char*>(std::malloc(mlen + 1));
		if (!mp) {
			std::cerr << ("cannot allocate memory\n");
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mp, p);
	}
	~String()
	{
		if (mp)
			std::free(mp);
	}
	std::size_t length()const
	{
		return mlen;
	}
	void print()const
	{
		std::cout << '[' << mp << ']' << '\n';
	}
private:
	std::size_t mlen;
	char* mp;
};
  
int main() {
	String str("bugun sinifin ozel fonksiyonlarini isliyoruz");

	str.print();
	if (str.length() > 10) {
		String sx("Ben blok icerisinde kullanilacak bir yaziyim");
		sx.print();
		sx = str;
		sx.print();
		(void)getchar();
	}
	str.print();
}

!!!!! Yukarýdaki sýnýf için bir tane daha deficit var. Self-assignment olmasý durumunda gene Undefined behaviour oluyor.

int main(void){
	int x = 10;

	x = x; // sentaks olarak hatalý deðil hatta buna self assignment deniyor. Bu iþlem sonucunda x'in deðeri deðiþmeyecek.
}
Fakat, HANDLE sistemine sahip sýnýf nesnelerinde self-assignment yapýldýðýnda devreye giren araç copy assignment.
	Copy assignment içerisinde hem deep copy hem de resourse release yapýldýðýndan dolayý, eski adres free edilecek
		ve yeni bir bellek bloðu allocate edilecek. Bundan dolayý da eski adreste tutulan bilgi kaybolucak. 
Self-assignmenttan kaynaklý problemin önüne geçmek için adresleri kontrol edicez. Eðer atama operatörünün sol tarafý ile sað tarafýndaki operandýn
	adresleri ayný ise bu ayný nesne demektir. Kontrolü yapmak içinde this pointeri kullanýcaz. this pointeri
	kopyalama iþleminin yapýldýðý sýnýf nesnesinin adresini döndürüyor. sað tarafý için ise parametre deðiþkeni olarak yollanan sýnýf nesnesinin
		adresini alarak yapýcaz. Örneðin
		this == &class1;

class String {
public:
	String& operator=(const String& other) 
	{
		if(this == &other) // eðer bu true dönerse self-assignemnt var demek.
			return *this;
		mlen = other.length();
		std::free(mp);
		mp = static_cast<char*>(std::malloc(mlen + 1));
		if (!mp) {
			std::cerr << ("cannot allocate memory\n");
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mp, other.mp); 
		return *this;
	}
	String(const String& other) : mlen(other.mlen) // eðer burada mlen'i MIL ile hayata getirmeseydik derleyici otomatik olarak default initialization yapacaktý
	{
		mp = static_cast<char*>(std::malloc(mlen + 1));
		if (!mp) {
			std::cerr << ("cannot allocate memory\n");
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mp, other.mp); // other.mp kopyalama iþlemi yaptýðýmýz sýnýf nesnesinden deðiþkenin referansýný kullanarak adreste tutulan yazýyý
		// yeni adrese kopyalýyoruz.
	}
	String(const char* p) : mlen(std::strlen(p))
	{
		mp = static_cast<char*>(std::malloc(mlen + 1));
		if (!mp) {
			std::cerr << ("cannot allocate memory\n");
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mp, p);
	}
	~String()
	{
		if (mp)
			std::free(mp);
	}
	std::size_t length()const
	{
		return mlen;
	}
	void print()const
	{
		std::cout << '[' << mp << ']' << '\n';
	}
private:
	std::size_t mlen;
	char* mp;
};

Self-assignment'a karþý önlem alma sebebimiz salaklarýn x = x yapmasýndan dolayý deðil.

void func(Myclass* m1, Myclass* m2)
{
	*m1 = *m2; // Eðer bu fonksiyonun parametrelerinin ikisine de yanlýþlýkla ayný sýnýf nesnesi geçilirse burada UB olacak.
}
Veya bir fonksiyon bir sýnýfýn adresini döndürüyor ve bu sýnýfýn adresini iki kere yanlýþlýkla kullanýrsak bu da UB'ye sebep olacak.
Bu tarz durumlarýn önüne geçmek, self-assignmenttan doðacak hatalarý engellemek için o kontrolü yapýyoruz.



ÖZETLE
Copy constructor deep copy iþlemini yaparken, Copy assignment hem deep copy hem de resource release yapar.
Copy constructor aldýðý sýnýf nesnesine initialization iþlemi yaparken, copy assignmenta gelen sýnýf nesnesi hali hazýrda init. edilmiþtir.
Copy assignmentta, self-assignment için kontrol yapýlmasý gerekiliyor, yapýlmaz ise UB'ye yol açýyor.







