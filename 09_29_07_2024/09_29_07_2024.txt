1- Member functionlar, sýnýfýn private bölgesinde bulunan data memberlara eriþebilirken
	global fonksiyonlar eriþemez(global fonksiyonda sýnýfýn adresini alan parametre var)

class myClass{
public:
	void func(int x); // mx ve my deðiþkenlerine eriþir
private:
	int mx, my;
};

void func_(myClass* p, int x); // mx ve my deðiþkenlerine eriþemez

2- Scope farký. Member functionlar class scope'a sahip iken, global/free/standalone functionlar global/namespace
	scope'a sahip. Global fonksiyonlar için name lookup kurallarý devreye girecek. Member functiona eriþmek için
	o sýnýf türüne ait bir nesne üzerinden arrow veya dot operatörü ile eriþmemiz gerek. 

3- Global fonksiyonlar ile member fonksiyonlar için kullanýlan name lookup kurallarý farklý.
---------------------------------------------------------------------------------------

			Member fonksiyonlarýn tanýmý nasýl yapýlýr?

1- .cpp dosyasýnda fonksiyonun normal tanýmý yapýlýr. Normal fonksiyondan tek fark fonksiyon
	class scopeta olduðu için fonksiyon adýnýn önüne sýnýfýn adý ve scope res. operatörü kullanýlýr.
	<geri dönüþ türü> <sýnýf_adý>::<fonksiyon_adý_parametreleri>
	void human::move(void){/*code*/}

//myclass.h
class myClass {
public:
	void set(int x, int y);
	void ref(myClass& r);
private:
	int mx, my; // non-static data member
};
//myclass.cpp
void myClass::set(int x, int y) {
	mx = x; 
	my = y;
	/*
		Global fonksiyonlarda name lookup çalýþma prensibi;
		-Bulunduðu blokta ismi ara
		-Kapsayan blok(lar)da ismi ara
		-global namespacede ara
		Eðer mx ve my global olarak tanýmlanmamýþsa name lookup hata verecek çünkü isimleri bulamayacak.
		Bu fonksiyon myClass sýnýfýnýn non-static bir member function'ý olduðu için her sýnýf türünden nesnenin
			kendine ait set fonksiyonu olacak. 
		Ayný zamanda set myclassýn bir fonksiyonu olduðu için içerisinde kullanýlan isimlerin aramasý þu þekilde olacak;
		-Bulunduðu blokta ismi ara
		-Kapsayan blok(lar)ta ismi ara
		-Sýnýfýn içerisinde ismi ara
		-Global namespacede ara
		Name lookup mx ve my nesnelerini ararken globalde aramadan önce, sýnýf nesnesinin içerisinde arayacak.
		mx ve my nonstatic data member olduðu için her sýnýf türünden nesnenin kendine ait mx ve my data memberlarý olacak.
			(bu structta kullanýlan deðiþkenler gibi iþte)
		Member functionlar sýnýflarýn private regionunda bulunan data memberlara da eriþebiliyorlar

	*/
}

int main() {
	myClass m1, m2, m3;
	m1.set(5, 3);
	m2.set(2, 7);
	m3.set(4, 8);
	/*
		Burada m1, m2 ve m3'ün kendine ait mx ve my nesneleri var.
	*/
}
----------------------------------------------------------------------------------
Sýnýf nesneleri globalde de tanýmlanabilir. 

myClass g;
void myClass::ref(myClass& r){
	r.mx = r.my; // L value ref üzerinden private alandaki data memberlara eriþebiliriz.
	Myclass x; // yerel bir sýnýf türünden nesne tanýmladýk
	x.my = x.mx; // yerel nesne ile de eriþebiliriz

	mx = my; // hiçbir þey kullanmadan da eriþebliliriz.

	/*
		Member functionlar örtülü olarak çaðrýldýklarý sýnýf türünün adresini de aldýðý için
			private regionda bulunan tüm memberlara eriþebiliyoruz. 
	*/
} 

----------------------------------------------------------------------------------
Name Hiding/Masking
int mx = 45;
void myClass::set(int x, int y) {
	int mx = 45;
	/*
		Zaten myClass içerisinde mx adlý bir data member vardý. Yerel olarak mx deðiþkenini tanýmlayarak
		myclass içerisinde bulunan mx'i "name masking/hiding/shadowing" yapmýþ olduk. 
		Buna raðmen sýnýf içerisindeki mx'e eriþmek istiyor isek 2 yol var.
		1- Scope resolution operatörü
			sýnýfismi::datamember -> myClass::mx;
		2- 
	*/
	myClass::mx = mx; // atama operatörünün saðýndaki operand, local olan mx, solunda kalan ise sýnýfýn içindeki mx
	/*
		Block scopetaki isim class scopetaki ismi maskeleyebildiði gibi, sýnýf içindeki isim namespacedeki ismi 
			name hiding'e maruz býrakabilir. Global namespacede bulunan nesneye eriþmek için gene scope resolution
			ama unary prefix olan.

	*/
	myClass::mx = 33; // sýnýf nesnesinin içindeki mx'e 33 deðeri atanýyor.
	::mx = 10; // globaldekine 10 verdik.
	mx = 44; // yerel mx'e 44 deðeri set edildi

	myClass::mx = mx + ::mx;
}

----------------------------------------------------------------------------------
Bir member function, baþka bir member functioný çaðýrdýðýnda örtülü olarak tuttuðu pointerý
	çaðýrdýðý member functiona veriyor.
class testClass {
public:
	void foo(int x, int y);
	void bar(int x);
};
void testClass::foo(int x, int y) {
	bar(x);
	bar(y);
	/*
		Burada bar fonksiyonuna foo içerisinde örtülü olarak tutulan testClass* pointerýda veriliyor.
		Eðer derleyici bar adýnda bir nesnenin ismini block scopeta bulamaz ise globalde aramak yerine
			class scopeta arayacak. Hem foo hem bar ayný sýnýf türünden nesnenin adresini kullanarak çaðrýlacak
		Global namespacete bar isminde bir fonksiyon olmasý önemli deðil. Ýlk olarak class scopeta arayacaðý için
			global function name masking'e uðrayacak.
	*/
	foo(x - 1, y - 1); // recursive member function call
}
----------------------------------------------------------------------------------
2- inline olarak header dosyasýnda yapýlýr. Bu sayede tek bir kez tanýmlabilir ve ODR(one definition rule) çiðnenmemiþ olunur.
#pragma once  // Tekrar tanýmlamayý önler (bu pragma her derleyicide olmayabilir derleyici özelinde bu)
class myClass {
public:
    inline void set(int x, int y);  // Inline fonksiyon bildirimi
};

// Inline fonksiyon tanýmý
inline void myClass::set(int x, int y) {
    // Fonksiyon içeriði
}
----------------------------------------------------------------------------------
1- Member functionlar overload olabilir.
class myclass{
public:
	void bar(int x);
	void bar(int x, int y);
private:
	void bar(int x, int y, double z);
}; // bir fonksiyounun publci veya privateda olmasý önemli deðil. Private keywordü sadece bir region belirliyor
	// scope deðiþtirmiyor. 

2- Member functionlarýn redeclare edilmesi sentaks hatasý
class myclass{
public:
	void bar(int x);
	void bar(int x); 
}; // sentaks hatasý, redeclaration member functionlar için yok.
----------------------------------------------------------------------------------
class myclass{
public:
	void bar(double x);
private:
	void bar(int x);
};
void myclass::bar(int x){
	bar(x); // (bu kýsmý 189. satýrdan sonra oku) int parametreli fonksiyona çaðýracak / recursive
	bar(static_cast<double>(x)); // double parametreli fonksiyon çaðrýlacak
}
int main(){
	myClass m;
	m.bar(12); 
	/*
		Bu sentaks hatasý! Sebebi ise name lookup sürecinde double parametreli fonksiyonda int türünden
			double türüne promotion var ama private bölümde olan int parametreli fonksiyon ile exact match var.
			Bundan dolayý name lookup int parametreli fonksiyonda sonlanacak, context kontrolü yapýlacak ve SON olarak
			access control yapýldýðýnda sentaks hatasý verecek. Çünkü int parametreli fonksiyon private region içerisinde
			ve client kod bu bölüme eriþemez. Bundan dolayý access control safhasýnda sentaks hatasý verecek.
	*/
	m.bar(1.2); // bu sentaks hatasý deðil access control kýsmý baþarýlý olacak ve çalýþacak.
}

// Bir fonksiyon x.myClass::set(3, 5); þeklinde de çaðrýlabilir. Böyle yapýldýðýnda niteleme yapmaya gerek kalmýyor.
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
																CONST SEMANTÝÐÝ
.
void foo(Data* p);  mutator/set fonksiyonu. 
	Mutator fonksiyonlara bakýldýðýnda, gönderilen parametre deðiþkeninin deðerinin deðiþtirilebileceði bilgisini alýyoruz.
void bar(const Data* p); Accessor/get fonksiyon.
	Accessor fonksiyonlarda ise gönderilen deðiþkenin sadece salt okuma(read-only) amaçla kullanýlabileceði bilgisini veriyor.

	Mutator-Accessor referans semantiði içinde ayný. 
void foo(Data& p);  mutator/set fonksiyonu. 
void bar(const Data& p); Accessor/get fonksiyon.

Const semantiði overload içinde kullanýlabilir.
void foo(Data& p);
void foo(const Data& p);
Const overloading baya önemli. Bu sayede const olan ve olmayan nesne ayrý ayrý ele alýnýyor.
	Pointer semantiði içinde geçerli bu durum.

BURASI KISA BÝR TEKRARDI. Þimdiki konu çok önemli, sýnýflar ile alakalý.


Nasýl ki global fonksiyonlarda const kullanýmý önemli ise sýnýflarýn member functionlarýnda da kullanmak önemli.
	Eðer fonksiyon, member fonksiyon deðil global fonksiyon olsaydý þöyle gözükecekti.
	void foo(Myclass* p); set/mutator .
	void foo(const Myclass* p); Const keywordü var get/accessor

	Bir member fonksiyonun const yapma sentaksý normalden farklý. public/private regionda tanýmlanmýþ fonksiyonun
		parametre parantezinin yanýna const yazýlýyor.
class Myclass{
public:
	void foo()const; // Bu fonksiyon accessor/get fonksiyon - const function
	void bar();	// mutator/set - non-const function
};
Member fonksiyonlarý yazarken const correctness çok önemli. O yüzden member fonksiyonlarý yazarken

-Sýnýfýn non-static veri elemnlarý fonksiyon tarafýndan deðiþtirilmiyorsa o fonksiyon const olmalý önergesi YANLIÞ!!
	non-static fonksiyonun const üye olup olmamasýnýn sýnýf nesnesinin veri elemanlarýyla doðrudan alakasý yok.
	Sýnýf nesnesinin problem domainindeki anlamý ile ilgisi var. Yani eðer problem domanindeki sýnýfýn statei deðiþmiyorsa const olabilir.


class Fighter{
public:
	void cry_name();
private
	char* pname;
}
Yukarýda, Fighter için bir sýnýf oluþturuldu. cry_name fonksiyonu dövüþçünün ismini ekrana yazdýrýyor olsun.
	Eðer sadece ekrana oyuncunun ismini yazdýrýyor, baþka bir þey yapmýyorsa bu fonksiyon const olabilir.
	Eðer ekrana hem oyuncunun ismini yazdýrýyor hem de her oyuncunun ismi söylendiðinde güç kaybetmesine sebep oluyorsa bu fonksiyon
		const olamaz çünkü sýnýfýn stateini deðiþtirdi. 
	pname bellek bloðunda oyuncunun adý tutuluyor olsun. Ben pname'in gösterdiði adresi deðiþtirmedim ama adresteki ismin üzerine yazdým.
		Bu durumda sýnýfýn data memberýnýn deðeri deðiþmemiþ oldu "o zaman ben bunu const yapayým" demek doðru deðil. Problem domaininde
		sýnýfýn statei deðiþiyor.

ÖZETLE
-Bir fonksiyonun const olup olmamasý sýnýfýn data memberlarýnýn deðerinin deðiþip deðiþmemesi ile alakalý deðil. Problem domainindeki
	durumun deðiþip deðiþmemesi ile alaklý.


class Eng {
public:
	void foo(); // non-const
	void bar()const; // const
private:
	int mx;
	int* mp;
};
/*
	Yukarýdaki foo fonksiyonlarýnýn gizli parametreleri þu þekilde
	void foo(Eng*); //non-const
	void bar(const Eng*)const;  // const
*/
void Eng::foo() {
	mx = 5; // hiçbir hata yok
}
void Eng::bar()const{ // const keywordü orada olmazsa sentaks hatasý
	mx = 5; // sentaks hatasý
}
Sýnýfýn const üye fonksiyonlarý, sýnýfýn non-static veri elemanlarýný deðiþtiremezler. Deðiþtirmeleri sentaks hatasý.
	Deðiþtirememelerinin sebebi gizli parametrelerinin const T* olmasý. Const keywordünün asterisk atomunun solunda olmasý
	iþaret edilen adresdeki nesnenin deðerinin deðiþmesini engellemesi. 


Bir sýnýfýn const olan üye fonksiyonu, ayný sýnýfýn non-const üye fonksiyonunu çaðýramaz. 
void Eng::foo() {
	bar(); // Burada T* türünden const T* türüne bir dönüþüm var. Logical const oluyor. Sentaks hatasý yok
}
void Eng::bar()const{ 
	foo(); // Burada const T* türünden T* türüne dönüþüm var. Sentaks hatasý var
}

Bir pointerýn nesnesinin tuttuðu adresteki nesnenin deðeri const üye fonksiyon tarafýndan deðiþtirilebilir.
void Eng::bar()const {
	*mp = 5; // Bu legal, deðiþtirilen deðer sýnýf nesnesinin gösterdiði adres deðil, adresi tutulan nesnenin deðeri deðiþiyor.
}
----------------------------------------------------------------------------------
ÖNEMLÝ!!!
Bu kýsým biraz karmaþýk olabilir. Diyelim ki Person problem domainimizde private regionda bulunan bir data member
	o sýnýf içerisinde fonksiyonlarýn kaç defa çaðrýldýðýný tutacak ve ben bu deðeri istediðim bir zamanda get edebileceðim.
	Yani her seferinde o sýnýftan bir fonksiyon çaðýrdýðýmda m_debug_count 1 artacak.
	2 fonksiyon olsun get_name ve get_debug_count. 
	get_name kiþinin ismini verecek bize. Sýnýf statei üzerinde hiçbir deðiþiklik yapmýyor. Ýsmini öðrenmiþ oluyoruz sadece
		yani fonksiyon const olabilir. m_debug_count 1 artacak
	get_debug_count fonksiyonuda ayný þekilde problem domainindeki kiþinin statei üzerinde deðiþiklik yapmayacaðý için
		const olabilir. Bu fonksiyon çaðrýldýðýnda m_debug_count artmayacak.
#include <string.h>
class Person{
public:
	std::string get_name()const;
	int get_debug_count()const;
private:
	int m_debug_count = 0;
}

std::string Person::get_name()const{
	m_debug_count++; 
/*
	semantik olarak bir problem yok. Çünkü m_debug_count domain üzerinde state deðiþikliðine sebep olmayacak fakat sentaks hatasý var.
		get_name fonksiyonu const olduðu için sýnýf içerisinde bulunan data memberlarý üzerinde
		deðiþiklik yapamaz çünkü low-level const. Ama bu fonksiyonun const correctness açýsýndan da const olmasý gerek.
	Bu durumun önüne geçmek için bir keyword var. MUTABLE. Eðer bir data member mutable keywordü ile tanýmlanýr ise o data memberýn
		const fonksiyonlar ile deðiþtirilebileceðini söylüyoruz. (baþka bir iþlevi daha var ama ileride görücez)
*/
};	


#include <string.h>
class Person{
public:
	std::string get_name()const;
	int get_debug_count()const;
private:
	mutable int m_debug_count = 0; // artýk const fonksiyonlar bu deðiþkenin deðerini deðiþtirebilecek. Çünkü derleyiciye
									// "bu data memberýnýn deðiþmesi problem domaindeki sýnýfýn durumunu deðiþtirmiyor" bilgisini verdik.
}
std::string Person::get_name()const{
	m_debug_count++; 
}
mutable keywordü ile tanýmlanmýþ bir data memberýn, o sýnýf nesnesinin problem domainideki karþýlýk geldiði durumla doðrudan alakasý yok.
	Bu sayede mutable ile taýnmanmýþ nesneler üzerinde const üye fonksiyonlar deðiþiklik yapabiliyor.

Caching mekanizmasý : Bir fonksiyon içerisinde bir deðer hesaplanýyor. Her seferinde bu deðeri tekrar tekrar hesaplamamak için
	son hesaplanmýþ deðer bir deðiþkende tutuluyor. Bu deðer mutable bir nesnede tutuluyor çünkü doðrudan problem domainindeki sýnýf ile alakasý
	yok.Caching bir kaç farklý yerde kullanýlýyor anlamsal olarak bu da bunlardan bir tanesi. 
	Bir iþi her seferinde sýfýrdan yapmak yerine son yaptýðý iþi kaydediyor ve onu kullanýyor.
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
																	THIS POINTER
This pointerý fonksiyon içerisinde kullanýldýðýnda, o fonksiyonu çaðýran sýnýf nesnesinin adresini alýyor.
	ÖNEMLÝ! this keywordü sýnýfýn yerini deðil sýnýf nesnesinin adresini alýyor. Nesnenin kendisini kullanmak istiyor isek
		*this þeklinde yazmamýz gerek.
	DÝKKAT! this pointerýnýn oluþturduðu ifade PR value expression.

Kullanýlamayacaðý alanlar:
-Global bir fonksiyonun içerisinde kullanýlmasý sentaks hatasý
-Sýnýfýn statik bir üyesinin içinde kullanýlmasý sentaks hatasý
-Addressof operatörünün sað operandý olarak(this pointerinin oluþturduðu ifade PR value olduðu için)
Yani sadece non-static üyeleri için kullanýlabilir.


#include <iostream>
class Myclass{
public:
	void func();
	void bar();
	void foo();
private:
	int mx, my, mz;
};
void Myclass::func(){
	std::cout << "this = " << this << '\n';
	//*this -> bu m deðiþkeninin kendisi.
	//&this -> sentaks hatasý çünkü addressof operatörü L value expr istiyor. this PR value.
	/*
		this keywordü, name masking olduðu durumlarda da kullanýlabilir. Fakat, bu kullanýlmasý gerektiði anlamýna gelmiyor.
		Ýlk sýrada zaten bu name masking olayýnýn olmasýný engellememiz gerekiyor. 
		Ek olarak, scope resolution var zaten böyle bir durum için. Kullanýlmasý yanlýþ deðil ama doðru da deðil. Gereksiz kullanmaya gerek yok
	*/
}
int main(){
	Myclass m;
	std::cout << "&m = " << &m << '\n';
	m.func();
}
----------------------------------------------------------------------------------
																		THIS KULLANIM YERLERÝ
1- Sýnýf türünden nesnelerin adresini parametre deðiþkeni olarak alan fonksiyonlarý member function ile çaðýrmak istediðimizde
	member functioný çaðýran sýnýf nesnesinin adresini göndermek için this kullanabiliriz.
void fg1(Myclass* p);
void fg2(Myclass& p);
void Myclass::bar(){
	fg1(this); // bar fonksiyonunu hangi nesne çaðýrýrsa çaðýrsýn, çaðýran nesnenin adresi this keywordü ile gönderilecek
	fg2(*this); // bu referans semantiði olduðu için nesnenin kendisini gönderiyoruz. 
}
int main(){
	Myclass m;
	m.bar();
}

2- Fonksiyonu çaðýran sýnýf nesnesinin adresini döndüren üye fonksiyonlarýnda kullanýlýyor. Bu fonksiyonlarýn geri dönüþ deðeri
	o sýnýf türünün adresi oluyor. Bunu döndürmek için this kullanýlýyor. 
	Ayný durum referans semantiði içinde geçerli. Nesnenin adresi yerine kendisini döndürebiliriz (L value reference)
class Myclass{
public:
	Myclass* foo();
	Myclass& bar();
}
Myclass* Myclass::foo(){
	//code
	return this;
}
Myclass& Myclass::bar(){ // referens semantiði
	//code
	return *this;
}

3- Bu referans semantiði ile alaklý. Fluent API(CPP'de chaining deniyor) için this kullanýlabiliyor. Ayný zamanda
	operator overloading oluyor bu özellikte.
class Eng{
public:
	Eng& foo();
	Eng& baz();
	Eng& bar();
}
Eng& Eng::foo(){
	return *this;
}
Eng& Eng::bar(){
	return *this;
}
Eng& Eng::baz(){
	return *this;
}
int main(){
	Eng myeng;
	myeng.foo().baz().bar(); // her fonksiyon L value ref döndürüyor ve birbirini çaðýrmaya devam ediyor.
								// burada overloading var mesela. Buna chaining(CPP) ya da fluentapi.
}

const üye fonksiyonunda this pointerý ile adres döndürülemez. This, kendisini çaðýran nesnenin adresini döndürüyor const T* türünden T* türüne
	dönüþüm olmadýðý için sentaks hatasý verecke.
class Eng{
public:
	Eng* foo()const{
		return this; // sentaks hatasý, çaðýran nesne const T* türünde, this T* türü döndürmeye yeltenecek. Dönüþüm olmadýðý için sentaks hatasý
	}
}

Eðer const bir fonksiyondan this ile adres döndürmek istiyor isek geri dönüþ deðeri const T* türünden olmalý.
	Ayný durum referans semantiði içinde geçerli. 
const Eng* foo()const{
	return this; // Sentaks hatasý yok, this const Eng* döndürecek.
}


const overloading(veya function overloading) member functionlar için çok sýk kullanýlýyor.

class Myclass{
public:
	void foo();
	void foo()const;
}
-Const olmayan nesneler için 449daki fonksiyon
	Const olan nesneler için 450deki fonksiyon çalýþacak demek bu. 

#include <iostream>
#include <vector>

int main() {
	using namespace std;

	vector<int> v{ 1, 4, 7, 12, 8 };
	v.at(2) = 5;
	auto aval = v.at(3);
	// Burada hem vector üzerinde deðiþiklik yapabildik hem de döndürdüðü referansý bir deðiþkende tuttuk.
	
	const vector<int> cv{ 1, 4, 7, 12, 8 };
	auto v1 = cv.at(3); 
	cv.at(4) = 2; // sentaks hatasý veriyor çünkü cv vektorü const. Const overloading yüzünden const int& döndüren sýnýf fonksiyonunu
					// çaðýrýyor. Bundan dolayý deðiþiklik yapýlamýyor vektör üzerinde. 
}



Bir fonksiyonun .cpp dosyasý ile sýnýfýn kendi içerisinde tanýmlanmasý ayný deðil.

class Myclass{
public:
	void set1(int x){
		mx = x;
	}
	void set2(int x);
private:
	int mx;
}

void Myclass::set2(int x){
	mx = x; 
}

set1 ve set2 fonksiyonlarý tanýmlamalarý ayný olsa da, ayný iþlevi yapýyor olsalarda ayný deðiller.

Sýnýfýn üye fonksiyonlarýnda ODR çiðnenmeme zorunluluðu var global fonksiyonlarda olduðu gibi.
	ODR violate etmemek için fonksiyonun inline olmasý gerek. 
Inline yapmak için bir kaç farklý yok.
-Fonksiyonun tanýmýný bþalýk dosyasýnda yapmak. Fonksiyonu baþlýk dosyasýnda tanýmlarsak fonksiyona inline keywordünü koymamýza gerek yok.
myclass.h
class Myclass{
public:
	inline void set1(int x);
private:
	int mx;
}
inline void Myclass::set1{
	mx = x;
}
------------------------------
class Myclass{
public:
	void set1(int x);
private:
	int mx;
}
inline void Myclass::set1{
	mx = x;
}
------------------------------
class Myclass{
public:
	inline void set1(int x);
private:
	int mx;
}
void Myclass::set1{
	mx = x;
}
------------------------------
-Eðer üye fonksiyonun tanýmý sýnýf içerisinde yapýlýrsa implicit olarak inline oluyor.

class Myclass{
public:
	void set1(int x){
		mx = x;
	} 
private:
	int mx;
}
inline keywordü yok ama fonksiyonun tanýmý sýnýfýn içerisinde yapýldýðý için bu bir implicit inline fonksiyon

Inline expansion kullanýrken de dikkat etmek gerekiyor. Bir üye fonksiyonun kullandýðý incomplete type'ýn eðer tanýmý
	derleyicide yok ise, ve bu tanýmý farklý bir baþlýk dosyasýnda yapmýþ isek hem client, hem biz kaynak dosyasýný include etmemiz gerekiyor.
	Tanýmý kaynak dosyasýnda yapmýþ olsaydýk sadece kaynak dosyasýnýn include etmesi yetecekti. Bu probleme "dependency" deniyor. 

----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
																SINIF NESNELERININ HAYATA BAÞLAMASI
																SINIF NESNELERININ HAYATLARININ SONLANMASI
.
Bir sýnýf nesnesinin hayata baþlamasýný saðlayan, sýnýf nesnesini kullanýlabilen bir varlýk hali getiren
	üye fonksiyonuna CONSTRUCTOR deniyor. 
Býr sýnýf nesnesinin hayatýný bitiren üye fonksiyona da DESTRUCTOR deniyor. 

1- Constructor ve destructor sýnýfýn member functionlarý. Global fonksiyon, statik üye fonksiyonu OLAMAZ!
	Non-static member function olmalý.

CONSTRUCTOR
1- Constructor üye fonksiyonu, sýnýfýn ismi ile ayný olmalý.
2- Constructor için geri dönüþ deðeri kavramý yok. Yani void bile yazýlmayacak.
3- Constructor const üye fonksiyonu da olamaz. Non-const non-static olmasý gerek.
4- Constructor overload edilebilir bir fonksiyon.
5- Constructorlar private kýsýmda da bulunabilir. Fakat, sýnýfýn private bölgesinde bulunan fonksiyonlarýn
	dýþarýdan eriþilmeye çalýþýlmasý sentaks hatasý. Access control kýsmýnda hata olucak
6- .cpp dosyasýnda veya baþlýk dosyasýnda inline olarak tanýmý yapýlabilir.
7- 
class Eng{
public:
	Eng();
	Eng(int);
	Eng(int, int);
	Eng(int, double);
private:
	Eng(double, int, char*);
};

Eng::Eng(int, double);