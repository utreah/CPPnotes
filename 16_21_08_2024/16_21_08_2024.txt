SUBCSCRIPT OPERATORUNUN OVERLOAD EDÝLMESÝ

a[b] ifadesi operator overload edilmiþ ise þu ifadeye dönüþüyor.
	a.operator[](b); -> subscript operatörünün oluþturduðu ifade bir l value olduðu için bu operatörün geri dönüþ deðeri
		l value ref.

REFERENCE QUALIFIERS
Sýnýfýn non statik üye fonksiyonlarýný niteleyen niteleyicilere denir.
 a- bir non-statik fonksiyonu sadece l value ref kabul eden hale getirebilir
 b- yukarýdaki maddenin r value ref versiyonu
 c- bunlarý fonksiyon overload etmek için kullanabiliriz.
 Bir önceki not dosyasýnda var bunlar.
 void func(int)&;
 void func(int)&&;
 void func(int)const &;
 void func(int)const &&; // çok bir anlamý yok ama mümkün.


 Subscript ne zaman overload ediliyor?
	Eðer problemin soyutlanmasýyla ortaya çýkan durumda array-like gibi bir durum söz konusu ise, yani verilerin contigous(ardýþýk/sýralý)
		olarak bellek üzerinde tutulmasý söz konusu ise subscript operatörü overload ediliyor. 

1-Array-like
-std::string
-std::array
-std::vector
-std::deque
- Bazý iterator sýnýflarý: Veri yapýlarýndaki öðelerin konumunu tutma görevini yapýyor iteratorler.
- vector<int>::iterator
- std::unique_ptr
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
													OVERLOADING DEREFENCING AND MEMBER SELECTION ARROW 
.
Pointer-like olan sýnýflar var. Yani bu sýnýflar tam olarak raw pointer deðil fakat pointer gibi iþlemleri var. 
	Mesela x sýnýfý var ve bu sýnýfý tutan bir pointer sýnýfý(y sýnýfý) var. Burada amaç y sýnýfýný kullanarak x sýnýfýnýn içeriðine
	eriþmek ve kullanmak. Dereferencing operatörü için adres gerekiyor ve bu sýnýf nesneleri adres olmadýðý için sentaks hatasý oluþturuyor.
	Bu hatanýn önüne geçmek için içerik operatörünü(*) overload ediyoruz. 

	Ýçerik operatörü unary, prefix olduðu için operatör overload fonksiyonunun parametresi yok. Ve bu overload sonucunda o nesnenin
		içeriðine eriþmek istediðimiz için geri dönüþ deðerinin L value reference olmasý gerek.

		myclass& operator*(); 

#include <iostream>
class Eng {
public:
	void foo();

};

class EngPTR {
public:
	EngPTR(Eng* p);
	Eng& operator*();
};
int main(void) {
	EngPTR ptr = new Eng;

	(*ptr).foo();
	ptr.operator*().foo();
}
--------------------------
standart kütüphaneden bir örnek.
#include <vector>
#include <iostream>
int main(void) {
	using namespace std;

	vector<int> ivec{ 4, 5, 3, 2, 6, 8, 0, };
	auto iter = ivec.begin();
	
	vector<int>::iterator iter2 = ivec.begin();
	cout << *iter;
	++*iter;
	*iter = 987;
}

38:40



------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------










