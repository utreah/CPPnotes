Big 3
	-Destructor
	-Copy Constructor
	-Copy assignment
Big 3 kuralý, Modern CPP öncesi, eðer yukarýdaki 3 adet special member functiondan birini biz yazar isek diðer iki fonksiyonu da
	bizim yazmamýz gerektiðini söyleyen kural. Modern CPP'de olmamasýnýn sebebi dile Move Ctor/assignment fonksiyonlarýnýn eklenmesinden dolayý.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
												
#include <iostream>

class Eng{};

void foo(const Eng&);	// 1- Bu fonksiyon const L value ref türünden deðer alýyor
void foo(Eng&&);		// 2- Bu fonksiyon R value ref türünden deðer alýyor
/* Yukarýdaki fonksiyonlara ek 2 adet daha fonksiyon yazýlabilir*/

/*
void foo(Eng&);
void foo(const Eng&&); -> hoca bu fonksiyonun semantik karþýlýðý olmadýðýný söyledi. Daha ileride anlatabilirmiþ
*/
Eng bar();
Eng&& baz();
int main() {
	Eng myeng;

	foo(myeng); // myeng L value expression olduðu için 1. fonksiyon çaðrýlacak
	/*
		Temporary Object diye bir konu görücez ileride. Alttaki ifade onla alakalý. Temporary objectlerin isimleri olmuyor. 
			Ýsimleri olmadýðý için R value expression. 
	*/
	Eng{}; // Bu bir temp object. Ýsmi yok, deðer kategorisi R value
	foo(Eng{}); // Eng{} r value olduðu için 2. fonksiyonu çaðýracak.

	/*
		R value oluþturmanýn derste hocanýn anlattýðýna göre 2 yolu daha var.
		1- static cast kullanmak
		2- std::move fonksiyonunu kullanmak.
			Hoca bu fonksiyonu ileride anlatacak. Dediðine göre yanlýþ isimlendirilmiþ bir fonksiyon. Çünkü 'move' yani hareket saðlamýyor.
				Aldýðý L value kategorisine sahip nesne alýyor R value döndürüyor. R value alýyor R value döndürüyor. Yani her türlü R value döndürüyor.
	static_cast<Eng&&>(myeng); 
	std::move(myeng);
	*/

	foo(bar()); // bar'ýn geri dönüþ deðeri R value deðer kategorisinde. 2. fonksiyon çaðrýlacak
	foo(baz()); // 2. fonksiyon çaðrýlacak.

	foo(Eng{}); 
}
// C türü tür dönüþüm operatörlerini kullanmak yerine, istisnai durumlar harici, ilk önceliðimiz her zaman CPP diline ait tür dönüþüm operatörleri olmalý.
Fallback Mekanizmasý: L value deðerler için copy constructor çaðrýlýyor. R value deðerler için move constructor. Eðer herhangi bir sebepten dolayý
	move constructor yok ise hem L hem R value deðerler copy constructorý çaðýracak. Buna fallback deniyor. Eðer foo(Eng&&) fonksiyonu olmasaydý
		R value deðer kategorisindeki ifadeler foo(const Eng&) fonksiyonunu çaðýracaktý. 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

																MOVE CONSTRUCTOR
Derleyicinin yazdýðý Move constructor/assignment fonksiyonu, sýnýfýn
	-non statik
	-inline
	-public fonksiyonu -> bu durum bütün special member functionlar için geçerli.
Eðer bir nesne hayatýna halen daha devam edecek, kullanýlacak bir nesnenin kaynaklarýný alýyor ise bu iþlem
	copy constructor tarafýndan deep copy olarak yapýlacak. Fakat nesnenin kaynakalarý alýndýktan sonra, bu nesne bir daha kullanýlmayacak
		destructor ile hayatýna son verilecek ise, yok edilecek nesnenin kaynaklarýný 'çalmak' için Move constructor çaðrýlacak.
	Yani ana sýnýf nesnesinde tutulan adresler yeni sýnýf nesnesine aktarýlacak. Bu çalma iþlemiyle beraber ana sýnýf nesnesi
		statei destructable olarak deðiþtirilecek ve destructor çaðrýldýðýnda kaynaklarýnýn çalýndýðýný bildiði için onlarý free etmeye çalýþmayacak. 
	move constructora gelen nesneler R value referans deðer kategorisinde. Yani move fonksiyonu mutator durumunda. 
Move constructor/assignmentýn bir hatanýn önüne geçmekten öte daha verimli hale getirme durumu var. Çünkü move ctor/asg olmasaydý bile
	copy constructor ile yapýlabilirdi fakat bu da programýn yavaþlamasýna veriminin düþmesine sebep olurdu. Varlýk nedeni Gereksiz kopyalamalardan kaçýnmak

class Myclass {
public:
	Myclass(Myclass&&); // move constuctor -> mutator
	Myclass(const Myclass&); // copy constructor -> accessor

	Myclass& opeeator=(const Myclass&); // copy assignment
	Myclass& operator=(Myclass&&); // move assignment
};
Hayata getirirken copy constructor deðil move constructor ile hayata getirecez.
class Myclass {
public:
	Myclass(const Myclass& r) : ax(r.ax), bx(r.bx), cx(r.cx){};
	/*
		R parametre deðiþkeni L value reference olduðu için data memberlarý hayata getirirken l value data type olarak hayata getirdi.
			
		Bir R value referansý tutan parametre deðiþkeninin veri türü L value veri türündendir. Yani 'Myclass&& r' ifadesindeki r, R value referansýna sahip
			iken r'ýn kendisi L value reftir. Move constructorýn çaðrýlabilmesi için gönderilen ifadelerin R  value expression olmasý gerekiyor.
			ax(r.ax) ifadesindeki r.ax L value ref olduðu için move constructor için uygun deðil. Bizim bu ifadeyi compile timeda R value expressiona döndürmemiz
				gerekiyor. Bunu da std::move() fonksiyonu ile yapýyoruz.
	*/

class Myclass {
public:
	Myclass(const Myclass& r) : ix(r.ix), dx(r.dx), cx(r.cx) {}; // copy ctor
	Myclass(Myclass&& r) : ix(std::move(r.ix)), dx(std::move(r.dx)), cx(std::move(r.cx)) {}; // move ctor
private:
	int ix;
	double dx;
	char cx;
};

Eðer sýnýf nesnesinde HANDLE kullanýlmýyor ise Rule of Zerodan dolayý kodun derleyici tarafýndan yazýlmasýna izin vermek gerekiyor.

11. derste kullandýðýmýz String sýnýfýna yazýcam Move constructorýný

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

class String {
public:
	

	String& operator=(const String& other)
	{
		if (this == &other) // eðer bu true dönerse self-assignemnt var demek.
			return *this;
		mlen = other.length();
		std::free(mp);
		mp = static_cast<char*>(std::malloc(mlen + 1));
		if (!mp) {
			std::cerr << ("cannot allocate memory\n");
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mp, other.mp);
		return *this;
	}
	String(const String& other) : mlen(other.mlen) // eðer burada mlen'i MIL ile hayata getirmeseydik derleyici otomatik olarak default initialization yapacaktý
	{
		mp = static_cast<char*>(std::malloc(mlen + 1));
		if (!mp) {
			std::cerr << ("cannot allocate memory\n");
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mp, other.mp); // other.mp kopyalama iþlemi yaptýðýmýz sýnýf nesnesinden deðiþkenin referansýný kullanarak adreste tutulan yazýyý
		// yeni adrese kopyalýyoruz.
	}
	String(String&& other) : mlen(other.mlen), mp(other.mp)  // copy constructor
	{ 
		/*
			Hayata sona erecek nesnenin pointerý ve string uzunluðu kopyalandý. String sýnýfýnýn destructorý
				eðer mp nullptr tutmuyor ise free ediyor. Bundan dolayý bizde mp'yi nullptr yapýyoruz. Bu sayede ömrü sona eren
					nesnenin destructorý çaðýrýlsa bile mp free edilmiyor. 
		*/
		other.mp = nullptr;
		other.mlen = 0; // bunu neden 0 yaptýðýmýzý hoca ileride anlatýcam dedi
	}


	String(const char* p) : mlen(std::strlen(p))
	{
		mp = static_cast<char*>(std::malloc(mlen + 1));
		if (!mp) {
			std::cerr << ("cannot allocate memory\n");
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mp, p);
	}
	~String()
	{
		if (mp)
			std::free(mp);
	}
	std::size_t length()const
	{
		return mlen;
	}
	void print()const
	{
		std::cout << '[' << mp << ']' << '\n';
	}
private:
	std::size_t mlen;
	char* mp;
};

int main() {
	String str(String{ "Bugun hava cok guzel" });
	str.print();
} 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
																	MOVE ASSIGNMENT

class Myclass {
public:
	Myclass(const Myclass& r) : ix(r.ix), dx(r.dx), cx(r.cx) {}; // copy ctor
	Myclass(Myclass&& r) : ix(std::move(r.ix)), dx(std::move(r.dx)), cx(std::move(r.cx)) {}; // move ctor
	Myclass& operator=(const Myclass& r) // copy asg
	{
		ax = r.ax;
		bx = r.bx;
		cx = r.cx;
		return *this;
	}

	Myclass& operator(Myclass&& r) // move assignment
	{
		ax = std::move(r.ax);
		bx = std::move(r.bx);
		cx = std::move(r.cx);

		return *this;
	}
private:
	int ix;
	double dx;
	char cx;
};

HANDLE sistemleri için move assignment içine resource release yapmamýz gerekiyor. Resource release yapýldýktan sonra 
	deðerleri atýyoruz ve en son olarak kaynaðýn adresini nullptr yapýyoruz. 
String& operator=(String&& other)
{
	if (this == &other)
		return *this;
	std::free(mp); // bunu yapmamýzýn sebebi kaynak sýzýntýsý önlemek
	mlen = other.mlen;
	mp = other.mp;

	other.mp = nullptr;
	other.mlen = 0;
	return *this;
}
-------------------------

#define _CRT_SECURE_NO_WARNINGS
#include <iostream>

class String {
public:
	

	String& operator=(const String& other)
	{
		if (this == &other) // eðer bu true dönerse self-assignemnt var demek.
			return *this;
		mlen = other.length();
		std::free(mp);
		mp = static_cast<char*>(std::malloc(mlen + 1));
		if (!mp) {
			std::cerr << ("cannot allocate memory\n");
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mp, other.mp);
		return *this;
	}
	String(const String& other) : mlen(other.mlen) // eðer burada mlen'i MIL ile hayata getirmeseydik derleyici otomatik olarak default initialization yapacaktý
	{
		mp = static_cast<char*>(std::malloc(mlen + 1));
		if (!mp) {
			std::cerr << ("cannot allocate memory\n");
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mp, other.mp); // other.mp kopyalama iþlemi yaptýðýmýz sýnýf nesnesinden deðiþkenin referansýný kullanarak adreste tutulan yazýyý
		// yeni adrese kopyalýyoruz.
	}
	String(String&& other) : mlen(other.mlen), mp(other.mp)  // copy constructor
	{ 
		/*
			Hayata sona erecek nesnenin pointerý ve string uzunluðu kopyalandý. String sýnýfýnýn destructorý
				eðer mp nullptr tutmuyor ise free ediyor. Bundan dolayý bizde mp'yi nullptr yapýyoruz. Bu sayede ömrü sona eren
					nesnenin destructorý çaðýrýlsa bile mp free edilmiyor. 
		*/
		other.mp = nullptr;
		other.mlen = 0; // bunu neden 0 yaptýðýmýzý hoca ileride anlatýcam dedi
	}
	String& operator=(String&& other)
	{
		if (this == &other)
			return *this;
		std::free(mp); // bunu yapmamýzýn sebebi kaynak sýzýntýsý önlemek
		mlen = other.mlen;
		mp = other.mp;

		other.mp = nullptr;
		other.mlen = 0; -> bunu aþaðýda açýklýyorum. "Moved-from state"
		return *this;
	}

	String(const char* p) : mlen(std::strlen(p))
	{
		mp = static_cast<char*>(std::malloc(mlen + 1));
		if (!mp) {
			std::cerr << ("cannot allocate memory\n");
			std::exit(EXIT_FAILURE);
		}
		std::strcpy(mp, p);
	}
	~String()
	{
		if (mp)
			std::free(mp);
	}
	std::size_t length()const
	{
		return mlen;
	}
	void print()const
	{
		std::cout << '[' << mp << ']' << '\n';
	}
private:
	std::size_t mlen;
	char* mp;
};

int main() {
	String str(String{ "Bugun hava cok guzel" });
	str.print();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
L value deðer kategorisine sahip, hayatýna devam eden bir nesnenin kaynaklarýný çalmak.
#include <iostream>
int main() {
	{

		std::string str(10000, 'A'); // buna filler deniyor. String 10bin adet A ile dolduruluyor.

		std::string sx = str; // copy constructor çaðrýlýr.

		/*
			str burada L value deðer kategorisine sahip bir nesne. stryi artýk kullanmayacam o yüzden kaynaklarýný çalmak için
				std::move kullanýcam.
		*/

		std::string sy = std::move(str);
		/*
			std::move ile str nesnesi R value deðer kategorisine verildi ve kaynaklarýný bu sayede çaldým.
			Buna maruz kalmýþ kaynaðý çalýnmýþ nesnelere "moved-from state/object" deniyor
		*/

	} // buraya geldiðinde destructor çaðrýlacak

}
Aksi belirtilmedikçe, standart kütüphanelerinde veya üçüncü parti kütüphanelerde moved-from state/objectler için þu 3 garanti var.

a) Valid state guarantee (geçerli durum garantisi)
	Çalýnmýþ nesne hala geçerli olmalý, yani sýnýfýn invariantlarý(doðru çalýþmasý için gereken temel koþullar) bozulmamýþ
		durumda olmalý. Standart kütüphane/3. parti kütüphaneler(aksi belirtilmedikçe) bu garantiyi saðlýyor. 

b) Unspecified state guarantee (belirsiz durum garantisi)
	Taþýnmýþ nesnenin deðerleri belli deðildir. Standarta göre hangi deðeri tuttuðunu bilemeyiz. Yalnýzca geçerli bir nesne olduðunu biliriz(valid state)
		Yani nesne içerisindeki fonksiyonlar, destructor vs çalýþmasý gerektiði þekilde çalýþmaya devam eder.
	std::string s1 = "abc";
	std::string s2 = std::move(s1); 
		Bu iþlem sonrasýnda hem s1 hem s2 birer std::string'tir ama içinde ne var bilemeyiz. Boþ da olabilir, "abc" de kalmýþ olabilir.
		.size(), .length() gibi fonksiyonlar çaðrýldýðýnda hiçbir problem yaþanmaz program çökmez, sorunsuz destruct edilebilir.

c) Destructible and Assignable guarantee
	Moved-from nesne her zaman destruct edilebilir veya yeni bir deðer atamasý yapýlabilir.

#include <iostream>
#include <string>

int main() {
    std::string s1 = "Merhaba Dunya";
    std::string s2 = std::move(s1);

    std::cout << "s2: " << s2 << "\n";  // Beklenen: "Merhaba Dünya"
    std::cout << "s1 (moved-from): '" << s1 << "'\n";
    std::cout << "s1.size(): " << s1.size() << "\n"; // standart kütüphane moved-from state implementasyonunda size'ý 0 yapýyor.

    // s1 hâlâ güvenle kullanýlabilir yani assignment yapýlabilir(3. garanti)
    s1 = "Tekrar atandi";
    std::cout << "s1 yeniden: " << s1 << "\n";
}
s2: Merhaba Dunya
s1 (moved-from): ''
s1.size(): 0
s1 yeniden: Tekrar atandi


Moved from stateteki nesnenin kullanýlmasý Undefined Behaviour oluþturmaz. 
	Mülakatlarda sorulabilir.
Moved-from stateteki nesnenin kullanýlabilme garantisini söyleyen kütüphanenin kendisi.
	Standart kütüphane bize söylüyor geçerli olup olmadýðýný.
	3. parti kütüphaneler ise doðru dökümante edilmiþ ise bize invalid veya valid state olup olmadýðýný söylemesi gerek.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

Kopyalama iþlemi yapýlan nesnelere copyable class deniyor. Ama bazý nesneler var ki bunlarýn kopyalanmasý ya mantýklý deðil(gereksiz)
	ya da probleme sebebiyet verebiliyor. Bunun önüne geçmek için copy ctor ve copy assignment delete ediliyor sýnýftan. 
Kopyalamaya kapatýlmýþ sýnýflara 'Non-copyable class' deniyor.

class Eng{
public:
	Eng(const Eng&) = delete;
	Eng& operator=(const Eng&) = delete;
}

int main(){
	Eng x, y;
	x = y; // sentaks hatasý
}

Bazý sýnýflarda ise kopyalama yasak iken move iþlemleri(moveable) serbest olabiliyor. Bu sýnýflara move-only class deniyor.


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
															DERLEYICI NE ZAMAN SPECIAL MEMBER FUNCTIONLARI YAZAR
Special member functionlarýn user-defined type haline getirilmesi durumunda fonksiyonun kodu derleyici tarafýndan yazýlmaz.


class Eng{

};
1- Sýnýfýn hiçbir fonksiyonu bildirilmemiþ ise derleyici tarafýndan bütün Special Member fonksiyonlarý yazýlýr.
2- Special member fonksiyonlar default keywordü ile bildirilmiþ ise derleyici tarafýndan yazýlýr.
	class Eng{
	public:
		Eng() = default;
		~Eng() = default;
		Eng(const Eng&) = default;
		Eng& operator=(const Eng&) = default;
		Eng(Eng&&) = default;
		Eng& operator=(Eng&&) = default;
	};


1- Default ctor parametre ile bildirilmiþ ise kodu derleyici tarafýndan yazýlmaz. Diðer special member fonksiyonlarýn kodu derleyici tarafýndan yazýlýr.
	class Eng{
	public:
		Eng(int); // kodu derleyici tarafýndan yazýlmayacak, diðer 5 fonksiyonu derleyici yazýcak
		~Eng() = default;
		Eng(const Eng&) = default;
		Eng& operator=(const Eng&) = default;
		Eng(Eng&&) = default;
		Eng& operator=(Eng&&) = default;
	};
2- DÝKKAT: Destructor bildirildiði zaman sýnýfýn move fonksiyonlarý(move ctor ve assignment) yok. Bunlarýn kodu derleyici tarafýndan yazýlmaz.
	copy ctor ve assignmentýn kodu yazýlýyor fakat bu TEHLÝKELÝ! Bu durum deprecated edilmiþ durumda yani ileride gelecek bir standartta sentaks hatasý olabilir.
	class Eng{
	public:
		~Eng();
		Eng() = default;
		Eng(const Eng&) = default;
		Eng& operator=(const Eng&) = default;
		// move ctor ve assgn derleyici yazmayacak.
	};
3- Copy constructor bildirildiðinde default constructor, move constructor ve assignment derleyici tarafýndna yazýlmayacak.
	Sadece destructor, copy assignment default edilecek.
	class Eng{
	public:
		Eng(const Eng&);
		~Eng() = default;
		Eng& operator=(const Eng&) = default;
	};
		Herhangi bir constructor declare edildiðinde derleyici defaultu yazmayacak.
4- Copy assignment bildirildiðinde, move ctor ve move assignment default edilmeyecek.
	class Eng{
	public:
		Eng& operator=(const Eng&);
		Eng() = default;
		~Eng() = default;
		Eng(const Eng&) = default;
	};
5- Move constructor bildiriðinde, default ctor ve move assignment yazýlmayacak, copy constructor ve assignment ise delete edilecek. 
	class Eng{
	public:
		Eng(Eng&&);
		~Eng() = default;
		Eng(const Eng&) = delete;
		Eng& operator=(const Eng&) = delete;
	};
6- Move assignment bildirildiðinde, move ctor yazýlmayacak, copy ctor ve assignment delete edilecek.
	class Eng{
	public:
		Eng& operator=(Eng&&);
		Eng() = default; 
		~Eng() = default;
		Eng(const Eng&) = delete;
		Eng& operator=(const Eng&) = delete;
	};


- Bir sýnýfa herhangi bir ctor bildirirsek(default hariç) derleyici default ctoru yazmayacak.
- Bir sýnýfýn her zaman destructorý vardýr.
- Bir sýnýfa eskiden büyük 3lü denilen -> destructor, copy ctor, copy assignmentlardan herhangi birini bildirirseniz
	derleyici move memberlarý bildirmez. Yani move memberlarý YOK!
- Býr sýnýfa move memberlardan birini bildirirseniz derleyici copy memberlarý delete eder.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////