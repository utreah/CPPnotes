# C++ Course Overview

## 01: Differences Between C and C++
## 02: Differences Between C and C++
## 03-04: References, Value Categories, Default Argument, Type Deductions
## 05: Scope, Name Lookup, Inline Functions
## 06: Type Cast, Constexpr, Attributes, Function Overloading
## 07: Function Overload Resolution
## 08: Classes, Access Specifiers, ODR
## 09: Classes, This Pointer
## 10: Constructors, Destructors
## 11: Copy Constructor
## 12: Move Constructor, Table for Constructors
## 13: Copy Elision, RVO, Conversion Constructor, Delegating Constructor, Temporary Objects
## 14: Friend Declaration, Operator Overloading (Till 17), Dynamic Objects
## 18: Named Constructor Idiom, Static Keyword, Singleton Pattern, Namespace, Nested Namespace, Using Declaration
## 19: Using Namespace Directive, Argument Dependent Lookup (ADL), Unnamed Namespace, Inline Namespace, Namespace Alias, Nested Types
## 20: Nested Types, Pimpl (Pointer Implementation) Idiom, Composition › Aggregation › Association, Has-a Relationship, Is-a Relationship, Dynamic Array, String Class, Small String Optimization
## 21: String in Parametric Template Patterns, Arguments and Interpretation Introduction, Moved From State, String Constructors, Initializer List, String::npos, Capacity
## 22: Insert, Resize, Erase, Pop_back, Find (find, rfind, find_first_of, find_last_of, find_first_not_of, find_last_not_of), Starts_with, Ends_with, Contains, Reverse, Remove, Sort, Remove-Ease Idiom, C_str, Data, Swap, Shrink_to_fit, Replace, Substr, Getline, Stoi, To_string, Copy, Puts
## 23: Inheritance (Public, Private, Protected) Introduction, Access Control in Inheritance, Upcasting, Object Slicing
## 24: Inherited Constructor, Polymorphic Class, Abstract and Concrete Class, Virtual and Pure Virtual Function, Override, Virtual Dispatch (+ Ctor and Dtor Exceptions), Virtual Constructor Idiom
## 25: Vptr (Virtual Function Table Pointer), Vtable, RTTI (Runtime Type Identification), Variant Return Type, Covariance, Downcasting Errors, Virtual Destructor, NVI (Non-Virtual Interface Idiom), Final (Final Class, Final Override), Private Inheritance, Private Inheritance vs Containment, Restricted Polymorphism, Protected Inheritance
## 26: Multiple Inheritance, Diamond Formation (DDD – Dreadful (Deathful) Diamond of Derivation), Virtual Inheritance, RTTI (Runtime Type Identification), Downcasting, Dynamic_Cast, Typeid, std::type_info, Sidecast
## 27: Type_id, Exception Handling, Traditional Error Handling, Terminate (Abort, Set_Terminate, Get_Terminate)
## 28: Std::Exception, Catch All (…), Translating and Rethrowing Exception, Basic Exception Guarantee, Strong Exception Guarantee, Nofail (Nothrow) Guarantee, Stack Unwinding, Function Try Block, Exception Relation Between Constructor and Destructor, Noexcept Specifier (Nothrow Guarantee or Nofail Guarantee), Noexcept Operator
## 29: Noexcept, SOLID ("Require No More Promise No Less"), Noexcept Relation with Optimization (Move and Copy Ctor), std::exception_ptr, Polymorphic Exception Idiom, Exception Dispatcher Idiom, Nested Exception, Introduction to Generic Programming, Template, Template Parameters (Type Parameter, Non-Type Parameter, Template Parameter), Template Argument, Deduction and Explicit Syntax Types, CTAD (Class Template Argument Deduction)
## 30: Specialization, Template Argument Deduction, Explicit Template Argument, Default Template Argument, Trailing Return Type, Partial Ordering Rules
## 31: Template Instantiation, Template Functions with Auto Keyword, Auto Return Type, Class Templates
## 32: Class Templates, Templates in Inheritance, Auto Type Deduction in Non-Type Templates, Lexicographical Compare Function, Explicit Specialization, Partial Ordering Rules, Partial Specialization
## 33: Partial Specialization, Dependent Name, Variable Template, Template Constraining, Alias Template, Default Arguments in Template, Perfect Forwarding
## 36: Last Class of Templates Unary Fold Expressions, Binary Fold Expressions, Standard C++ Library, STL (Standard Template Library), Introduction to Containers, Iterators, and Algorithms (Copy, Find)
## 37: STL, Iterators, Iterator Types, Const_Iterator, Bool Predicate, Unary and Binary Predicate, Lambda Expressions, Closure Type, Closure Object
## 38: Local Class, Lambda Expressions, IIFE (Immediately Invoked Function Expression), Mutable, Stateless and Stateful Lambdas, Positive Lambda Idiom, Trailing Return Type, Generalized Lambda Expressions
## 39: IIFE, Lambda Expressions, Initialization Assignment Split
## 40: Copy, Copy_n, Replace, Replace_Copy_If, Remove, Remove_If, Unique, Erase, Remove_Copy_If, STL Containers, Vector, Data, Front
## 41: Vector Functions, Capacity, Reserve, Front, Back, At, Emplace_Back, Emplace, Insert, Sort, Stable_Sort, Is_Sorted
## 42: Partial_Sort, Partial_Sort_Copy, Partition Algorithms, Partition, Stable_Partition, Partition_Copy, Basic Structure Binding, Is_Partitioned, Partition_Point, Heap Algorithms, Make_Heap, Pop_Heap, Sort_Heap, Deque, Iterator Invalidation, List
## 43: List, Linked List, Doubly Linked List, Forward List, Associative Containers, Strict Weak Ordering, Set, Multiset, Lower Bound, Upper Bound, Equal Range, Insert
## 44: Set, Multiset, Emplace, Find, Count, Contains, Erase, Extract, Copy, Inserter, Transparent Function Object, Emplace_Hint, Merge, Map, Multimap, Insert, Emplace, Make_Pair
## 45: Try_Emplace, Insert_Or_Assign, Unordered Associative Containers, Hash_Set, Hash_Map, Bucket, Bucket_Count, Load_Factor, Max_Load_Factor, std::Array
## 46: std::Array, To_Array, Container Adapters (Stack, Queue, Priority_Queue), Data Structure, ABT (Abstract Data Type), Stack, Push, Top, Pop, Size, Queue, Priority_Queue, Tuple, Get, Tuple_Element, Tuple_Element_T, Tuple_Size, Tuple_Size_V, Creating Custom Structured Binding Example for Tuple
## 47: std::Tuple with Reference, Tie, Apply, Advanced Function Pointers, Pointer to Member, Member Function Pointer, Functional Library, Reference_Wrapper, Generate, Ref, Cref, std::Bind, Not_Fn
## 48: Functional Library, Bind, Mem_Fn, Function, Invoke, Generate, Generate_N, Fill_N, Sorted_Range Algorithms, Set_Intersection, Set_Union, Set_Difference, Set_Symmetric_Difference, Search
## 49: Search, Search_N, Includes, Bitset, Set, Reset, Flip, Test, Any, None, All, To_String, To_Ulong, To_Ullong, Binary Search Algorithm (Binary_Search), Lower_Bound, Max, Min, Max_Element, Min_Element, Minmax_Element, Structure Binding
## 50: Structured Binding, Dynamic Objects, Operator New, Get_New_Handler, Set_New_Handler, Writing Our Own New_Handler, Placement New, Operator Delete
## 51: New Operator, Memory Library, Pointer-Like Classes, Smart Pointers (Unique_Ptr, Shared_Ptr, and Weak_Ptr (Not So Smart)), Unique_Ptr (Exclusive Ownership), Default_Delete, Make_Unique, Reset, Release, Get
## 52: Unique_Ptr, Partial Specialization of Unique_Ptr for Arrays, Sink Functions, Shared_Ptr, Reference Counter, Use_Count, Make_Shared
