Global namespacede tanýmlanmýþ fonksiyonlar için üç isim var.
1- global function
2- free function(daha yaygýn olaný)
3- stand-alone function
C dilinde member function gibi þeyler olmadýðý için kavram karýþýklýðýný önlemek için yeni terimler üretilmiþ.
Bu yazdýðým þey aþaðýdaki notlarý okuduktan sonra daha fazla anlam ifade edecek. 

CLASSES(SINIFLAR)

Class demek OOP demek deðil. C++ Nesne yönelimli programlama dili deðil. Çok paradigmalý bir dil.
	Yani Nesne yönelimli programlamaya da destek veriyor. 

Data abstraction: Problem domainindeki varlýklarýn yazýlýmsal olarak temsil edilmesi.

C dilindeki structures CPP dilinde sýnýf türünde. enum Class ise class-type deðil.
Bir sýnýfýn bildirimi çok basit. class keyword + class_tag. 
class myclass; -> non-defining declaration(forward declaration) Burada myclass adýnda bir class olduðunu söylüyoruz
	fakat bu classýn içerisinde neler olduðunu vermiyoruz. Yani bir declaration var burada.
	Her definition bir declarationdur ama her declaration bir definition deðildir. 

struct Nec{
	// C dilinde structlarýn içerisinde en az 1 adet struct member bulunmasý zorunlu.
	// CPP dilinde sýnýf türlerinin içi boþ olabilir. Bunlara "empty class" deniyor ve kullanýmý yaygýn.
};

Küme parantezlerinin arasýnda kalan alana "declarative region" deniyor.
Burada bildirilen varlýklara class members deniyor. Bu memberlarýn 3 kategorisi var.
	-data member
	-member function
		Bildirim global namespacede deðil sýnýf içerisinde yapýlýyor. Assembly koduna dönüþtürüldüðünde
			fonksiyon fonksiyondur nerede bildirildiðinin önemi yok. Bu dil düzeyinde öneme sahip bir kavram.
			1- Dilin diðer araçlarýyla daha uyumlu olmasý için
			2- Yazýlan kodun daha yüksek ifade gücüne sahip olmasý için
			3- Kodun daha yalýn olmasýný saðlýyor. 
	-type member/member type/nested type
		Nested typelar struct, enum türleri olabilir. 
		Nerede bütün türler nested type olabilir. 
class Nec{
	//declarative region
	int mx; // data member
	void foo(int); // member function
	struct Nested{}; // Nested type
	enum colour {Blue, Black, Red}; // Nested type
	using Dollar = double; // Nested type, bu sýnýfa özel bir type-alias bu
};


Sýnýf ayný zamanda bir scope belirtiyor. C ve CPP arasýnda fark var.
CPP;
namespace scope -> Bu C dilinde yok bunun yerine file scope var.
block scope
class scope		-> Bu scope C dilinde yok. 
function prototype scope
function scope


Öyle isim kullanýmlaýr var ki bu kullanýmlara iliþkin isimler bir sýnýf tanýmýnda aranýr(name lookup)
Sýnýf tanýmýnda arandýðý 3 adet senaryo var. Bu senaryolarýn oluþtuduðu kümeye "Qualified Name" deniyor
(bir sýnýf türü olmasý þartýyla)
1-Bir isim nokta operatörünün sað operandý olarak kullanýldýysa. x.y
2-Bir isim ok operatörünün sað operandý olarak kullanýldýysa. ptr->a
3-Bir isim scope resolution operatörünün sað operandý olarak kullanýldýysa. myclass::b;
#include <iostream>
struct mystruct{
	int x;
	static int y;
};
int main() {
	mystruct Nec;
	mystruct* NecPTR;
	auto a = x; // sentaks hatasý, x bir unqualified name. Name lookup mystruct sýnýfý içerisinde bulunan
				// x ile eþleþemez çünkü scopelar farklý.
	auto b = Nec.x;
	auto c = NecPTR->x;
	mystruct::y; // scope resolution ile eriþebilmek için eriþtiðimiz class member statik olmalý.
}
Kod derlenirken aþaðýdaki yolu izliyor. 
name lookup = Bu süreçte kullanýlan isimleri contexte  bakmadan bulmaya çalýþýyor. 
int main(void){
	int func = 10;
	func(10, 20); // Mesela burada name lookup func ismini bulacak. 
}
	context control = namelookup'ýn baþarýlý olmasýyla bulunan ismin legal olup olmadýðý kontrol ediliyor.
		Yukarýdaki kodda func name lookup aþamasýný baþarýyla tamamlasa da context controlde hata verecek. Çünkü 
			func int türünden bir nesne iken fonksiyon çaðrý operatörü ile kullanýlmýþ.

		access control = namelookup ve context control aþamalarýný geçtitken sonra, o isme eriþim izni
			olup olmadýðý kontrol edilir. private bir sýnýf üyesine dýþarýdan eriþmeye çalýþýrsak bu aþamada
				hata alýrýz. (C dilinde access control yok)
Golden Rules of Name lookup;
-Sýrayla yapýlýr. Önce bulunduðu blocktan tanýmlandýðý yere kadar arar, kapsayan bloktan kullanýldýðý bloða kadar
	arama yapar. Eðer kapsayan bloklarýn hiçbirinde bulunamaz ise namespacede arar. Bulamaz ise hata verir.
-Ýsim arama, aranan ismin bulunmasýyla sona erer bir daha baþlamaz.
class myclass{
	int x;
};
void func(int);
int main(){
	int func = 5;
	func(10); // burada int func'ý bulduktan sonra arama sona erecek. Context control namelookuptan sonra yapýlacak.
				// context control hata verdi diye ayný isim için tekrar namelookup yapýlmayacak.
	myclass Eng;
	Eng.x; // Bu hatalý. Çünkü classlarýn memberlarý default olarak private tanýmlanýyor(ileride görülecek)
			// name lookup baþarýlý olacak, context control baþarýlý olacak fakat access control hata verecek.
}
--------------------------------------------------------------------------------------------
Class memberlarý kendi içinde de iki gruba ayrýlýyor(nested type hariç)
Eðer static keywordü kullanýlmaz ise non-static member oluyor. Çok ileride öðrenilecek bu farklar
Data Members:
	-non-static data member
	-static data member
Member Functions
	-non-static member function
	-static member function
Nested Type
--------------------------------------------------------------------------------------------
Sýnýflarýn non-static memberlarý sýnýfýn kendisine ait. Sýnýfýn içerisinde tanýmlanan her non static deðiþken için
	gerekens sizeof(class) deðeri artacaktýr. Sýnýfýn içerisindeki memberlara object - instance deniyor.
	Buradaki object OOPdeki object ile ayný deðil. Non-static memberlara instance deniyor. 
class myclass{
	int x, y; // 8byte
};

Sýnýfýn hiçbir memberý yok ise sizeof deðeri 1 BYTE olacak. 1 Byte sýnýf için adres oluþturulabilmesi için
	gerekli alaný saðlýyor. Bir nesnenin bellek ihtiyacý asla 0 olamaz.


class myclass{
	int x;
	double x;
}; // sentaks hatasý, ayný isme sahip iki nesne olamaz.
class myclass{
	int x;
	void x(int);
}; // sentaks hatasý, ikisinin de ayný olamamasýnýn sebebi varlýðýn türü deðil, ayný scopeta olmalarý.

void func(int); //namespace scope
class myclass{
	int x;
	void func(int); // class scope
}; // Function overloading yok burada. Çünkü ikisinin de scopelarý farklý. FO olmasý için ayný scopeta olmasý gerek

class myclass{
	void func(int);
	void func(double);
}; // Ýkisi de ayný scopeta, imzalarý farklý, isimleri ayný olduðu için function overloading olur.

ÖNEMLÝ!!
Eðer bir fonksiyon ayný scopeta, ayný imza ve isim ile iki kez yazýldýysa buna function overloading deniyordu.
void func(int);
void func(int);
Mesela bu function redeclaration.
Fakat eðer classýn içerisinde bir fonksiyon iki defa yazýldýysa bu SENTAKS HATASI. Sýnýflarýn memberlarý için
	redeclaration söz konusu deðil. 
class myclass{
	void func(int);
	void func(int); 
};
--------------------------------------------------------------------------------------------


Sýnýf türlerinin 3 adet access specifierý var. Bu access specifierlar classýn memberlarýnýn nasýl eriþebileceðini
	belirleyen niteleyiciler. CPP dilinde access specifierlar keyword ve bölge(region) niteliyorlar.
	class sýnýf türünün memberlarý access specifier kullanýlmaz ise default olarak private iken
		struct sýnýf türünün memberlarý public. 
class MyClass{
	int x;
}; // Burada x private non-static member
struct MyStruct{
	int y;
}; // y burada public non-static member. 

Access Specifiers;
1-public
2-protected
3-private
Bir access specifier kullanýldýðýnda sonraki access specifiera kadar olan bölgeyi kaplýyor.
Kullaným þekli keyword + : -> public: / private: / protected: þeklinde. Ýki nokta üst üste tokený geliyor keywordten sonra

class Myclass{
	public:
	// sonraki access specifiera kadar bütün memberlar public olacak. Region vs bunlarý yukarýda notu var.
		// class'ýn parantez arasýnda kalan alana region deniyordu.

	int x; // x public
	double dval; // dval public

	private:
	int foo(); // foo fonksiyonu private

	protected: 
	int bar(int); // bar fonksiyonu protected
};
Access specifierlar sýnýf türünün içerisinde birden fazla kez kullanýlabilir.
class myclass{
	public:
	int x;
	private:
	int y;
	public:
	double z;
};

int main(){
	myclass m;
	auto a = m.y; // sentaks hatasý çünkü private membera eriþmeye çalýþýyoruz.
	auto b = m.x; // bir sýkýntý yok x public
}

-Client kod tarafýndan eriþilmesini istemediðimiz memberlarý private region içine koyuyoruz.
	Information hiding deniyor buna.
	Direkt olarak kullanýlmasý gereken/kullanýlan memberlarý da public region içine.

-Class içerisinde farklý access specifier içerisinde bulunan, farklý imza, ayný isme sahip fonksiyonlar
	function overload oluþturur.

class MyClass{
	public:
	void foo(int);
	private:
	void foo(double;)
}; Burada herhangi bir problem yok, isimler ayný, imzalar farklý ve scopelar ayný. public ve private keywordleri
	ayrý bir kapsama(scope) sahip deðil. Sadece ayný kapsam içerisinde regionlar oluþturuyor.


Public:		Herkese açýk, herkes tarafýndan kullanýlabilen.
Private:	Sadece class memberlarýna açýk, client tarafýndan kullanýlamayan.
Protected:	Bu keyword için C'den gelen bir karþýlýk yok. Ýleride öðreneceðimiz inheritance(miras/kalýtým) konusu ile alakalý bu.
				Onu öðrenene kadar protected ile private arasýnda bir fark yok bizim için.

Sýnýfýn data memberlarý private bölümüne koyuluyor. 
Bu sayede;
-O sýnýf hakkýnda öðrenilmesi gereken bilgi azalýyor. Çünkü data memberlarýný ve ne iþe yaradýklarý gibi
	bilgileri bilmemiz gerekmiyor. 
-Runtimeda çalýþma þeklinin deðiþmesini riske etmiyoruz.
	Data memberlarý üzerinde yanlýþlýkla yaptýðýmýz bir deðiþiklik programýn çalýþma zamanýnda farklý þekilde
	çalýþmasýna sebep verebilir. Private kýsmýnda tutarak bu riskten de kurtuluyoruz.


Baþlýk(.h) dosyasýnda bildirilen fonksiyonlara external functions deniyor. 
Class memberlarýný private region içine koyarak yapýlan information hiding zorunlu deðil. Bazý kiþiler
	data memberlarý vs private alana koyup, public regionda set/get fonksiyonlarý yazarak eriþmeye çalýþýyor.
	Information hiding sadece gerekli ise yapýlmalý. Gerekli deðilse yapýlmamalý. Dogma haline GETÝRME!

C dilinde private/public gibi keywordler yok fakat sadece o kaynak dosyasýnda kullanýlmasýný istediðimiz
	fonksiyon/deðiþkenleri static keywordü ile tanýmlayarak internal linkage'a ait hale getirebiliriz. Bu sayede
	baþka kaynak dosyalarý tarafýndan kullanýlamazlar. Diðer dosyalarda kullanýlmasýný istiyor isek
	fonksiyonlar ve deðiþkenleri baþlýk dosyasýnda extern keywordü ile bildirebiliriz.

Member function ile global/free fonksiyonlar arasýnda üretilen assembly kodu açýsýndan bir farklýlýk yok.
	Member function dil düzeyinde eklenmiþ, soyutlamayý arttýran, kodun okunmasýný ve anlaþýlmasýný arttýran bir araç.
	Tek farklýlýklarý member functionlar class scopea sahip iken, global functionlar file(C)/namespace(CPP) scopea sahip.
Soyutlamadan kasýt þu. attack adlý bir fonksiyonumuz olsun ve bu fonksiyon çaðrýldýðýnda diðer oyuncuya saldýrý yapýlsýn.
typedef struct {
	// player info
}Player;
void attack(Player* playerX, Player* playerY);
int main(){
	attack(&playerX, &playerY);
}
Burada hangi oyuncunun hangi oyuncuya atak yaptýðý belli deðil. Implementesyonun nasýl olduðunu bilmeye 
	baðlýlýk çok artýyor.

Eðer member function olsaydý þöyle olacaktý.
class Player{
	void attack(Player* player);
};
int main(){
	Player playerX;
	Player playerY;

	playerX.attack(playerY); // buradan playerX'in playerY'ye saldýracaðýný anlayabiliyoruz rahatça.
							// böyle bir soyutlama ve kod okuma kolaylýðý saðlýyor. Burada neden adresini parametreye
							// göndermediðimizin cevabý aþaðýda.
}
--------------------------------------------------------------------------------------------
Member functionlar için önemli bir özellik var. Member functionlar dot veya arrow operator ile eriþildiðinde
	görünen parametrelerinden hariç olarak bulunduðun classtan bir pointer deðiþken alýyor. 

class Eng{
public:
	void foo(); // non statik member function
};
foo fonksiyonunun görünen hiçbir parametresi yok. Fakat, member functionlarýn örtülü olarak 
	bulunduklarý sýnýfýn pointerýný alan bir parametre deðiþkenleri var. Yani görünen 0, 
	gerçekte en az 1 parametreleri var. void foo(Eng*); -> ayný bu þekilde Sentaks düzeyinde o pointer gözükmüyor.

void Foo(Nec*);
int main(){
	Eng myeng;

	myeng.foo(); // ben bu fonksiyonu dot operator ile çaðýrdýðýmda foo fonksiyonuna örtülü olarak
					// myeng'in adresini yolluyorum. myeng Eng sýnýf türünden bir deðiþken. Yani foo fonksiyonu
					// örtülü olarak foo(&myeng); þeklinde çaðrýlýyor.

	Foo(&myeng); // yukarýdaki member function ile olan fark görülebilir. Burada myeng'in adresini kendim yolladým.


	//Eðer çaðrý o sýnýf türünden bir pointer ile yapýlýr ise o pointer türünün gösterdiði nesne gönderilecek. 
	//Yani myeng gönderilecek
	Eng* engptr = &myeng;
	engptr->foo(); 
	myeng.foo(); // yukarýdaki ile ayný.
}
Class scopea sahip olmasý sayesinde, eðer birden fazla sýnýfta ayný isimde fonksiyon var ise class scope sayesinde
	o fonksiyonu çaðýran nesnenin sýnýfýnda aranýyor sadece.

class A{
public:
	void foo();
};
class B{
public:
	void foo();
};
int main(){
	A a;
	B b;

	a.foo(); // A sýnýf-türü içerisinde foo fonksiyonu aranacak. B sýnýfýndaki foo fonksiyonuna karýþmayacak bile.
			// Eðer global namespacede olsaydý problem olacaktý.
}
--------------------------------------------------------------------------------------------
Member function tanýmlamalarý nasýl yapýlýr?

Classlar özel durumlar harici baþlýk dosyasýnda tanýmlanýr. Mesela, oluþturulan sýnýfýn client kod tarafýndan
	kullanýlmasýný istemiyorsak, sýnýfý ya implementasyon dosyasýnda ya da nested type olarak tanýmlayabiliriz.
Classý baþlýk dosyasýnda tanýmladýktan sonra tanýmýný .cpp dosyasýnda yapýyoruz.

//class.h -> burada sýnýfý tanýmlýyoruz.

class Person{
public:
	void set_person_name(const char* p);
};
!!! ÖNEMLÝ
.cpp dosyasýnda tanýmýný yaptýðýmýz member function'ýn baþýna bulunduðu classýn ismi ve
	scope resolution operatörü gelmek zorunda. Eðer yazmaz isek global/free fonksiyon tanýmlamýþ oluruz.
//class.cpp -> 
void Person::set_person_name(const char* p){
	// kod
} Bu fonksiyon tanýmý Person sýnýfýnda bulunan member function'ýn tanýmý

void set_person_name(const char* p){
	//kod
} Bu fonksiyon tanýmý ise global namespacede tanýmlanmýþ bir fonksiyon. Ýkisi birbirinden farklý. 
--------------------------------------------------------------------------------------------
Buradaki notlar oluþturulan classexample.h ve classexample.cpp dosyalarýnda olacak. Önce oraya bak sonra buraya dön.
--------------------------------------------------------------------------------------------


--------------------------------------------------------------------------------------------


