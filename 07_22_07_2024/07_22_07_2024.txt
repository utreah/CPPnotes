
void foo(int *p)
void foo(int p[])
Pointer iki farklý þekilde gösterilebiliyordu. int* p veya int p[] þeklinde
	bundan dolayý bu redeclaration

void bar(int p[6]);
void bar(int p[7]);
void bar(int p[8]);
void bar(int* p);
Burada 1 tane overload var, parametreleri ayný hepsinin. 


void baz(int (*)[10]);
void baz(int (*)[14]);
void baz(int (*)[16]);
Burada 3 tane overload var hepsi farklý tür. Ýlk fonksiyon 10 elemanlý bir dizi istiyor
	diðerleri 14 ve 16 elemanlý. Bundan dolayý 3 adet overload var. Pointer to an array

void foo(int(int)) // most vexing parse için bir örnek aslýnda bu parametre. 
void foo(int (*)(int))
Bu function redeclaration. Birinci foo function type, ikinici function pointer type.
	Ýlk fonksiyondaki parametre pointer decay uðrayacaðýndan dolayý ayný olacak. redeclaration

void foo(int);
void foo(int*);
void foo(int&);
void foo(int&&);
4 adet overload var. Hepsi ayrý tür bunlarýn. 

Const overloading bir kelime var. Bunu daha önce görmüþtük aslýnda. const keywordünün &(referans) veya *(pointer) operatörlerinin
	solunda (low-level const) bulunmasý ile oluyor.
int foo(int const*)
int foo(const int*) 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

													FUNCTION OVERLOAD RESOLUTION(f.o.r)
.
Function overloading var ise, kaç tane olduðuna bakýlmaksýzýn fonksiyonu çaðýran ifadenin 
	hangi fonksiyon tarafýndan kullanýlacaðýna karar veren, bir dizi kurallarý ve özellikleri takip ederek yönetilen
		sürece function overload resolution denir.
Kurallarý iyi öðrenmek önemli! Sezgisel hareket sýkýntý yaratýyor. Örneðin;

void bar(long double);
void bar(char);

int main(){
	bar(4.5);
}
Soru 1) Kaç adet overload var? -> 2 adet overload var çünkü, ayný kapsamdalar, imzalarý farklý ve isimleri ayný
Soru 2) bar(4.5); deyimi hangi fonksiyonu kullanýr?
	Eðer long double parametreli denildiyse BU YANLIÞ. Problem ambiguity(karasýzlýk) ile alakalý
	4.5 ifadesi double türünden fakat fonksiyonlar long double ve char parametrelerine sahip.
	double -> long double tür dönüþümü tür geniþletme(promition)
	double -> char tür dönüþümü daraltma(narrowing conversion)
		Dilin kurallarý bu iki iþlem arasýnda karar veremediði için sentaks hatasý veriyor. Yazan hata da ambiguity ile alakalý.

f.o.r
a- Sentaks hatasý ile sonlanabilir
	1- n tane overload olmasýna karþýn overloadlardan hiçbiri fonksiyon çaðrýsý ile uyumlu deðildir.
	2- ambiguity: 2 ya da daha fazla overload arasýnda kalýndýðýnda dilin kurallarý hangi
		fonksiyonun seçileceðine dair bir kriter sunamýyor. 
b- Sentaks hatasý yok ise hangi fonksiyonun kullanýlacaðýný bulmuþtur.

f.o.r adým adým çalýþan, kendi içerisinde de alt süreçler geçiren bir süreç.
KURALLAR;

1- Ýlk aþamada f.o.r n tane fonksiyon overloadlarýný bir kümede topluyor. Bu kümeleme iþlemi yaparken
	fonksiyonu çaðrýsýnda parametreye gönderilen deðerin türü dikkate alýnmýyor. Oluþturulan bu kümeye
	function overload set deniyor. Bu kümedeki fonksiyonlara da candidate functions deniyor.
	ÖNEMLÝ! Bu küme oluþturulurken parametrede kullanýlan ifadenin int double char olmasý gibi þeyler dikkate alýnmýyor.
		ayný isme, farklý imzalara, ayný kapsama sahip BÜTÜN FONKSÝYONLAR ekleniyor buraya.


argüman sayýsý, argüman ve parametre türü(örtülü ok) - ayýrma iþlemi - viable functions - best viable
2- Function overload set içerisinde iki veya daha fazla candidate function var ise þu kurallar uygulanýr.
	-Argüman sayýsý kontrol edilir ve arg sayýlarý ayný olan fonksiyonlar sonraki adýma geçer.
	-Parametre türleri kontrol edilir. Bu aþamada eðer örtülü dönüþüm oluyor ise bunda bir sýkýntý yok.
		Dönüþüm sýrasýnda veri kaybýnýn olup olmamasý önemli deðil. Önemli olan dönüþümün olmasý
	-Bu aþamalardan geçen fonksiyonlar "viable functions" olarak ayrý bir küme oluþturur. 
		Eðer ilk aþamadan sadece 1 adet fonksiyon geldiyse buna 'best viable function' denir
Bu aþamada 1 tane bile viable function olmaz ise derleyici "ambiguity" hatasý verecek.

NOT: int türü ile çaðýrdýk fakat int parametreli bir fonksiyon yok fakat char var. Burada mesela narrowing conversion olur
	ve bu fonksiyon viable bir fonksiyon olduðu için bir sentaks hatasý olmaz. 

3- Eðer fonksiyonu çaðýran ve viable function parametrelerinin arasýnda bir dönüþüm var ise
	dönüþümün kalitesine göre en kaliteli olan seçiliyor. Bu kalite de dilin kurallarýyla belirleniyor.
	
	Aþaðýdaki kategori en düþükten -> en yükseðe. Variadic hep kaybeden, std conversion hep kazanan
	1-Variadic Conversion :En kalitesizin dönüþüm. Eðer ortada variadik fonksiyon dýþýnda baþka bir
		viable fonksiyon var ise her zaman o seçilir. variadic conversion en kötü dönüþüm.
	2-User-defined Conversion: Bu araç seti C dilinde yok CPP de daha öðrenmedik. Bu dönüþümler, dilin standartýnda olmayan
		fakat kullanýcýnýn bu dönüþümün yapýlabilmesi için oluþturduðu fonksiyona, derleyicinin bu fonksiyona çaðrý yaparak
		dönüþümün legal olmasýný saðlayan dönüþümlere denir. Variadik fonksiyona karþý kazanýyor, diðer dönüþümlere kaybediyor.

			struct Nec{ int x{}; };
			int main() {
				Nec mynec;
				mynec = 5; // fonksiyon yok ve bu sentaks hatasý
			}

			struct Nec{ 
				int x{}; 
				Nec(); 
				Nec(int); // fonksiyonu burada bildiriyoruz. Bu yazýlmaz ise Nec() fonksiyonu sentaks hatasýna sebep veriyor.
			};
			int main() {
				Nec mynec;
				mynec = 5; // artýk sentaks hatasý deðil çünkü derleyici struct içerisindeki fonksiyonu çaðýracak ve dönüþüm yapýlacak.
			}
	3-Standard Conversion: Dilin kurallarý gereði legal olan dönüþümler. Veri kaybýnýn olup olmamasý bu dönüþümün
		sorunu deðil. Burada legal olan, gerçekleþen tüm dönüþümler var.
		long double ==> char mesela burada dönüþüm var. Veri kaybý olmasý bu durumu deðiþtirmiyor.
		int ==> enum burada int türünden enum'a dönüþüm yok.
		enum ==> int türüne dönüþüm var.
		int* ==> double* türüne dönüþüm yok
		int* ==> void* türüne dönüþüm var
		void* ==> int* türüne ÖRTÜLÜ dönüþüm yok. Yukarýda olan dönüþümlerin hepsi ÖRTÜLÜ dönüþüm.
		int* ==> bool dönüþüm var. NULL ise 0, adres var ise 1

		Bir tane standart conversion olsaydý o seçilecekti. Birden fazla olursa ne olacak?

		void foo(double);
		void foo(int);
		void foo(unsigned int);
			Mesela burada 3 adet overload var ve çaðýrýlan ifadeye göre 3 adet standart conversion olabilir.

		Birden fazla std conversion olmasý durumunda fonksiyonu seçebilmek için üç kategoriye ayrýlýyor.
			-exact match: Ayný türden parametre deðiþkenleri olmasý durumu
			-promotion: Kendisinden daha yüksek öneme sahip bir deðiþkene promote edilmesi. short -> int
				int -> long vs.
			-standard conversion: En düþük öneme sahip. Exact match, promotion kategorilerine ait	
				en az bir tane deðiþken yok ise ve birden fazla standard conversion var ise ambiguity hatasý verecek

		1- Exact Match: Argümanla fonksiyonun parametresinin ayný tür olmasý.
			Ek olarak exact match olarak kabul edilen bazý durumlar var.
			a- fonksiyon parametresinin const, gönderilen argümanýn const olmamasý arasýnda yapýlan örtülü dönüþüm
				exact match kabul ediliyor.
				void foo(const int*);
				int main(){
					int x{};
					foo(&x); // gönderilen argüman int*, fonksiyon parametresi const int*. Burada örtülü dönüþüm var ama gene de exact match
				}
			
			b- Fonksiyon türünden, fonksiyon adresine türüne yapýlan dönüþümler exact match
				void foo(int (*)(int));
				int func(int);
				int main(void){
					foo(func); -> Burada function to pointer conversion olacak. Exact match
				}
			c- Array decay de exact match kabul ediliyor.
				void foo(int*);
				int main(){
					int ar[5]{};
					foo(ar); // array to pointer conversion var. Exact Match
				}
			d- L value referanstan R value referansa yapýlan conversionlar.
				void foo(int);
				int main(){
					int x{434};
					foo(x); // foo fonksiyonu l value ref istiyor ve biz ona l value yolladýk. Dönüþüm yok.
					foo(43); // R value referans yolladýk burada fonksiyonun parametresinin deðer kategorisini deðiþtirdik.
								// L value ref -> R value ref. Yapýlan bu dönüþüm exact match
				}
		2- Promotion: Ýki kategoriye ayrýlýyor. 
			a- integral promotion: int altý türlerden int türüne yapýlan conversionlar.
				- char 
				- unsigned char 
				- signed char 
				- short 
				- bool 
					türlerinden int türüne promotion var.

				void foo(int);
				void foo(double);
				int main(){
					foo('A'); // char türünden double türüne 'promotion' olmadýðý için int türüne promote edilecek.
								// eðer foo(int) olmasaydý conversion kýsmýnda iþleme alýnacaktý.
				}
			
			b- float türünden double türüne yapýlan promotion. Long double buna dahil deðil. Sadece flottan doublea
				void foo(long double);
				void foo(double);
				void foo(int);
				int main(){
					foo(3.5f); // float türünden int, double ve long double türüne CONVERSION var fakat
								// long double ve int türlerine promotion yok. Sadece double türüne promotion var.
				}
		
		3- Conversion: Eðer yukarýdaki kategorilerden hiçbiri yok ise standart conversion kullanýlýyor.
			Eðer birden fazla standart conversion var ise bu ambiguity hatasý. Promotion kýsmýndaki örnekte 
				birden fazla conversion var. float hem double, hem long double hem de int'e dönüþtürülebilir.
				Bu ambiguity hatasý verir.
			void foo(char);
			void foo(long double);
			void foo(double);
			void foo(int);
			int main(){
				// double parametreli fonksiyonu görmezden gel
				foo(3.4);  // sentaks hatasý verecek çünkü int, char ve double arasýnda conversion var.
				foo(3.4f); // floattan 3 türe conversion var. Sentaks hatasý, ambiguity

				// double parametreli fonksiyon eklendi
				foo(3.4); artýk sentaks hatasý deðil çünkü exact match var
				foo(3.4f); artýk sentaks hatasý deðil çünkü float -> double promotion var
			}
	
			void foo(unsigned int);
			void foo(long double);

			int main(){
				foo(12); // Argüman int türünden. int türünden unsigned int türüne yapýlan dönüþüm exact match olmadýðý
							için burada ambiguity var.
			}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ÖZEL DURUMLAR

1- const overloading: 
const olan ve olmayan nesneler için ayrý implementasyonlar yapýyoruz. Bunu yapmanýn en kolay yolu
	2 adet overload oluþturmak. const T* sadece read-only iken int* mutable yani yapýlan iþlemler çok farklý olacak.
void foo(int* param){
	std::cout << "Value of param: " << *param << std::endl;
}
void foo(const int* param){
	std::cout << "Value of param: " << *param << std::endl;
}

int main(void){
	const int x{45};
	int y{807685};

	foo(&x); // x const nesne ve const T* türünden T* türüne örtülü dönüþüm yok.
				// bundan dolayý foo(int*) fonksiyonu viable bile deðil. const int* parametreli fonksiyon çaðrýlacak.
	foo(&y); // burada her iki fonksiyonda viable olacak. Derleyici const olmayan parametreli fonksiyona
				// öncelik tanýdýðý için int* parametreli fonksiyon çaðrýlacak
 }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
2- Call by value ve call by reference olan fonksiyonlar: Bu overload þeklinin kullanýlmasýný önermiyorlar.

void bar(int);
void bar(int &);
void bar(const int &);
int main(){
	int x{};
	// const int& fonksiyonunu görmezden gel
	bar(x); // ambiguity, x bir l val reference. Hem int& hem de int ikisi de viable fonksiyon ve
				hangisinin seçileceðine dair bir kriter yok.
	bar(10); // 10 burada rvalue ref olduðu için int tarafýndan kullanýlacak

	//const int& fonksiyonu eklendi
	bar(10); // burada gene ambiguity oldu. const T& türlerine R value derleyicinin oluþturduðu
		temp val sayesinde kullanýlabiliyor. T ve const T& arasýnda ayrým yapan bir kural olmadýðý için
		ambiguity hatasý.
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
3- Parametrede varsayýlan argüman(default argument) olmasý

void foo(int, int = 0);
void foo(int);
int main(){
	foo(12); // default parametrenin olmasý ile ilk fonksiyon da viable oluyor. 
				// hangisinin seçileceðine dair bir kural olmadýðý için bu ambiguity.
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
4- NULL pointer

- C den gelen NULL makrosu kullanýlmýyor CPP'de. Bundan dolayý bir pointer parametre deðiþkenine
		null pointer göndermek için 0(sýfýr) yazýlýyor. Fakat bu da function overloading kýsmýnda aþýrý tehlikeli.
void func(int *);
void func(int); // bu 2.2 notundan sonra eklendi kabul et
int main(void){
	func(0); // Bir sýkýntý yok, int* parametreli fonksiyona null pointer olarak gidecek.
	// 2.2
	func(0); // Sýkýntý var çünkü 0 tam sayýsýnýn ilk fonksiyon için null pointera dönüþmesi standart conversion.
				// ikinci fonksiyonda ise EXACT MATCH var bundan dolayý ikinci fonksiyon çaðrýlacak.
				// Bu da kendi içinde problem. Ya biz pointer deðiþkenli fonksiyonu çaðýrmak istemiþ olsaydýk?
				// nullptr, nullptr_t türünden bir sabit keyword. 
	func(nullptr); // nullptr türünden diðer pointer türlerine örtülü dönüþüm var yani standart conversion.
					// tam/gerçek sayý türlerine dönüþüm yok.
}
	
- 2 farklý fonksiyonda pointer deðiþkenleri olmasý ve nullptr gönderilmesi ile ambiguity oluþur.
void func(int*);
void func(double*);
int main(void){
	func(nullptr); // iki fonksiyonda pointer aldýðý için ambiguity oluþur burada.
}
	
- Ýki adet standart conversion'un bulunduðu yerde ambiguity var.

void func(int*);
void func(double);
int main(void){
	func(0); // burada 0 hem int* için null pointer'a dönüþebilir hem de double türüne dönüþebilir. 
				//Bundan dolayý ambiguity var.
}

- Kütüphanelerde std::nullptr_t kullanýlabiliyor. Bu nullptr'in veri türü. Bunun kullanýlma sebebi 
	nullptr ile özel bir fonksiyonun overload olmasýný istiyor olabilirler. nullptr_t türünden diðer pointer
		türlerine dönüþüm var fakat pointer türlerinden nullptr_t türüne dönüþüm yok.

void func(std::nullptr_t t);
void func(int* t);
int main(){
	int x = 10;
	func(nullptr); // nullptr bþaka türlere dönüþüyor iki fonksiyonda viable aslýnda. Ama nullptr_t exact match olduðu
						// için o seçilecek.
	func(&x); // (int* t parametreli fonksiyonu görmezden gel) burada x int türünden ve int* türünden
				// nullptr_t türüne dönüþüm yok. Bu yüzden hata var burada	
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
5- void* vs bool

void func(void*);
void func(bool);

int main(){
	int x = 10;
	func(&x); // normalde x burada hem void* türüne hem de bool türüne convert olabiliyor. Bundan dolayý
				// bu iki fonksiyonda viable yani normal olarka ambiguity oluþmasý gerek. Fakat burada bir istisna var
					// void* bool'a göre öncelik alýyor. Daha önce görmüþtük bool türüne pointer deðiþkeni verilmesi 
					// durumunda deðiþken nullptr ise 0, deðil ise 1 deðerini alýyordu. Mantýk bu sadece burada istisna
					// olduðu için void* çaðrýlýyor.
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
6- Const ref istisnasý
	L value ref, R value reference'a baðlanmaz. 
	R value ref, L value reference'a baðlanmaz. Function Overloading için kullanýlabilir

void func(int&); // l value ref
void func(int&&); // r value ref
int main(void){
	int x = 10;
	func(12); // 12 r value olduðu için ikinci fonksiyon çaðrýlacak
	func(x); // x l value olduðu için ilk fonksiyon çaðrýlacak.
}
Yukarýdaki þekilde çok çýkmýyor karþýmýza ama const keywordlü olaný sýkýntý.

-const T& olmasý durumunda derleyici geçici bir nesne oluþturuyor. Bu sayede const L refler R value ref tutabiliyor.
#include <iostream>
void func(const int&){ // const L value reference == Hem L value ref hem de R value ref alabilir.
	std::cout << "func(const int&)\n";
}
void func(int&&){ // R value reference = Sadece R value ref
	std::cout << "func(int&&)\n";
}
void func(int&){
	std::cout << "func(int&)\n";
	
}
int main(){
	const int x{5};
	int y{12};
	func(y); // y nesnesi const olmadýðý için int& parametreli fonksiyonu çaðýracak
	func(x); // x nesnesi const olduðu için const int& parametreli fonksiyonu çaðýracak.

	func(34); // 34 bir R value olduðu için normalde hem const int& hem de int&& fonksiyonlarý viable oluyor.
				// çünkü const T& hem L hem R value tutabiliyordu(yukarýda açýkladým) normalde ambiguity olmasý gerekir
					// fakat CPP11(modern cpp) ile eklenen kural ile burada R Value Ref tercih edilecek.
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

7-expr bir ifade ve bu ifadenin primary value kategorisi L value reference.
Ben öyle bir iþlem yapmak istiyorum ki hem expr'ý kullanýcam hem de bunu R value ref olarak kullanmak istiyorum
2 yolu var bunu yapmanýn.
1- static_cast kullanmak.
	static_cast<int&&>(expr); -> expr ifadesi R value ref oldu þimdi. 
void foo(const int&){
	std::cout <<"const int&\n";
}
void foo(int&&){
	std::cout <<"int&&\n";
}
int main(void){
	int x = 10;
	foo(x); // const int& çaðrýlacak
	foo(static_cast<int&&>(x)); // x static cast sayesinde int&& türüne dönüþtü. Ve deðer kategorisi R value ref oldu.
									// int&& çaðrýlacak.
}

2- Compile timeda L value ref'i R value ref olarak, R value reference'ý R value olarak alýnmasýný saðlayan
	bir fonksiyon var. Bunun adý std::move(expr);
int main(){
	// yukarýdaki fonksiyonlarý kullanmaya devam

	foo(std::move(x)); // x'in deðer kategorisi R value referansýna geçti. 
}
Bu fonksiyon taþýma semantiði konusunda kullanýlacakmýþ.


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
8- Birden fazla parametre olmasý

	Birden fazla viable fonksiyon var ise ambiguity vermeden önce þu kuralý kontrol edecek;
		-en az bir parametrede diðerlerine üstünlük saðlayacak 
			ancak diðer parametrelerde diðerlerinden kötü olmayacak.
		Eðer bu koþulu saðlayan bir fonksiyon var ise o seçilecek yok ise ambiguity. 

void func(int, double, long);
void func(char, int, double);
void func(long, long, char);
int main(){
	func(12, 12u, 5); 
		/*
			12 burada ilk fonksiyon ile exact match iken diðerlerinde conversion var. Bu yüzden ilk fonksiyonun
				seçilebilmesi için diðer 2 parametre de ayný ya da daha iyi olmalý.
				12u unsigned int, ikinci parametrelerde double int ve long için std conversion olacak yani ayný.
				5 ise int long double char türüne std conversion olacak yani ayný. Bu durumda ilk fonksiyon overload edilecek.
		*/
	func(12, 12u, 5.f); 
		/*
			Burada ambiguity var. Çünkü üstünlük saðlayan parametre yok hatta ilk fonksiyonun ilk parametresinde
				exact match var. 5.f ikinci fonksiyonun son parametresi arasýnda promition var(conversiondan daha iyi)
					fonksiyonun diðer parametreleri diðer fonksiyonlarýn parametrelerinden kötü.
		*/
	func(12u, 12u, 5.f); 
		/*
			Ambiguity yok burada ikinci fonksiyon seçilecek. 12u unsigned int olduðu için int, char, long türlerine
				std conversion gerçekleþecek. 5.f float türünden double türüne ise promotion olacak. Bundan dolayý
					ikinci fonksiyon overload edilecek.
		*/

}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
9- bool distinct bir tür.	
	CPP'de bool ayrý bir veri türü. C dilinde olduðu gibi int boolean deðil. Karþýlaþtýrma operatörlerinin
		ürettiði deðer C dilinde int iken CPP dilinde bool türünden. Bu sayede function overloading konusunda
			ayrým yapabiliyoruz.
void func(int);
void func(bool);

int main(void){
	func(true); // exact match
	func(10 > 5); // bu da bool ile exact match. C dilinde functoin overloading olsaydý bu ambiguity oluþtururdu
					// çünkü elde edilen deðer int türünden olacaktý.
}

MÜLAKAT SORUSU!!!
func(123) yani R value ile çaðrýlýyor. Ekrana çýktý yapacak fonksiyon hangisi olur?

#include <iostream>
void foo(int && r){
	std::cout << "foo(int&& r)\n";
}
void foo(const int& r){
	std::cout << "foo(const int& r)\n";
}
void func(int&& r){
	foo(r);
}

int main(void){
	func(123);
}
CEVAP:
Ekrana const int& r parametreli fonksiyon yazar. func R value reference ile çaðrýlýyor. 
	foo ise r nesnesi ile yani L value reference ile çaðrýlýyor. const int& hem L hem R value ref alýyor.
	Burada foo'nun gönderdiði nesnenin Veri türü int&&. Referans kategorisi ile veri türü karýþtýrýlmamalý.
	r'nin int&& olmasý onun referans kategorisi ile alakasý yok. Bir nesnenin ismi her zaman L value reftir.

EK OLARAK
	Eðer R value ref olarak gönderdiðimiz deðeri R value ref olarak kullanmak istiyor isek
	std::move(r); þeklinde çaðýrmalýyýz diðer fonksiyonu. Bu sayede R value ref olarak gelen deðer, R value ref olarak
		gidebilir. int&& r parametreli fonksiyonun içinde foo foo(std::move(r))