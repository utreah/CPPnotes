
void foo(int *p)
void foo(int p[])
Pointer iki farklý þekilde gösterilebiliyordu. int* p veya int p[] þeklinde
	bundan dolayý bu redeclaration

void bar(int p[6]);
void bar(int p[7]);
void bar(int p[8]);
void bar(int* p);
Burada 1 tane overload var, parametreleri ayný hepsinin. 


void baz(int (*)[10]);
void baz(int (*)[14]);
void baz(int (*)[16]);
Burada 3 tane overload var hepsi farklý tür. Ýlk fonksiyon 10 elemanlý bir dizi istiyor
	diðerleri 14 ve 16 elemanlý. Bundan dolayý 3 adet overload var. Pointer to an array

void foo(int(int)) // most vexing parse için bir örnek aslýnda bu parametre. 
void foo(int (*)(int))
Bu function redeclaration. Birinci foo function type, ikinici function pointer type.
	Ýlk fonksiyondaki parametre pointer decay uðrayacaðýndan dolayý ayný olacak. redeclaration

void foo(int);
void foo(int*);
void foo(int&);
void foo(int&&);
4 adet overload var. Hepsi ayrý tür bunlarýn. 

Const overloading bir kelime var. Bunu daha önce görmüþtük aslýnda. const keywordünün &(referans) veya *(pointer) operatörlerinin
	solunda (low-level const) bulunmasý ile oluyor.
int foo(int const*)
int foo(const int*) 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

													FUNCTION OVERLOAD RESOLUTION(f.o.r)
.
Function overloading var ise, kaç tane olduðuna bakýlmaksýzýn fonksiyonu çaðýran ifadenin 
	hangi fonksiyon tarafýndan kullanýlacaðýna karar veren, bir dizi kurallarý ve özellikleri takip ederek yönetilen
		sürece function overload resolution denir.
Kurallarý iyi öðrenmek önemli! Sezgisel hareket sýkýntý yaratýyor. Örneðin;

void bar(long double);
void bar(char);

int main(){
	bar(4.5);
}
Soru 1) Kaç adet overload var? -> 2 adet overload var çünkü, ayný kapsamdalar, imzalarý farklý ve isimleri ayný
Soru 2) bar(4.5); deyimi hangi fonksiyonu kullanýr?
	Eðer long double parametreli denildiyse BU YANLIÞ. Problem ambiguity(karasýzlýk) ile alakalý
	4.5 ifadesi double türünden fakat fonksiyonlar long double ve char parametrelerine sahip.
	double -> long double tür dönüþümü tür geniþletme(promition)
	double -> char tür dönüþümü daraltma(narrowing conversion)
		Dilin kurallarý bu iki iþlem arasýnda karar veremediði için sentaks hatasý veriyor. Yazan hata da ambiguity ile alakalý.

f.o.r
a- Sentaks hatasý ile sonlanabilir
	1- n tane overload olmasýna karþýn overloadlardan hiçbiri fonksiyon çaðrýsý ile uyumlu deðildir.
	2- ambiguity: 2 ya da daha fazla overload arasýnda kalýndýðýnda dilin kurallarý hangi
		fonksiyonun seçileceðine dair bir kriter sunamýyor. 
b- Sentaks hatasý yok ise hangi fonksiyonun kullanýlacaðýný bulmuþtur.

f.o.r adým adým çalýþan, kendi içerisinde de alt süreçler geçiren bir süreç.
KURALLAR;

1- Ýlk aþamada f.o.r n tane fonksiyon overloadlarýný bir kümede topluyor. Bu kümeleme iþlemi yaparken
	fonksiyonu çaðrýsýnda parametreye gönderilen deðerin türü dikkate alýnmýyor. Oluþturulan bu kümeye
	function overload set deniyor. Bu kümedeki fonksiyonlara da candidate functions deniyor.
	ÖNEMLÝ! Bu küme oluþturulurken parametrede kullanýlan ifadenin int double char olmasý gibi þeyler dikkate alýnmýyor.
		ayný isme, farklý imzalara, ayný kapsama sahip BÜTÜN FONKSÝYONLAR ekleniyor buraya.


argüman sayýsý, argüman ve parametre türü(örtülü ok) - ayýrma iþlemi - viable functions - best viable
2- Function overload set içerisinde iki veya daha fazla candidate function var ise þu kurallar uygulanýr.
	-Argüman sayýsý kontrol edilir ve arg sayýlarý ayný olan fonksiyonlar sonraki adýma geçer.
	-Parametre türleri kontrol edilir. Bu aþamada eðer örtülü dönüþüm oluyor ise bunda bir sýkýntý yok.
		Dönüþüm sýrasýnda veri kaybýnýn olup olmamasý önemli deðil. Önemli olan dönüþümün olmasý
	-Bu aþamalardan geçen fonksiyonlar "viable functions" olarak ayrý bir küme oluþturur. 
		Eðer ilk aþamadan sadece 1 adet fonksiyon geldiyse buna 'best viable function' denir
Bu aþamada 1 tane bile viable function olmaz ise derleyici "ambiguity" hatasý verecek.

NOT: int türü ile çaðýrdýk fakat int parametreli bir fonksiyon yok fakat char var. Burada mesela narrowing conversion olur
	ve bu fonksiyon viable bir fonksiyon olduðu için bir sentaks hatasý olmaz. 

3- Eðer fonksiyonu çaðýran ve viable function parametrelerinin arasýnda bir dönüþüm var ise
	dönüþümün kalitesine göre en kaliteli olan seçiliyor. Bu kalite de dilin kurallarýyla belirleniyor.
	
	Aþaðýdaki kategori en düþükten -> en yükseðe. Variadic hep kaybeden, std conversion hep kazanan
	1-Variadic Conversion :En kalitesizin dönüþüm. Eðer ortada variadik fonksiyon dýþýnda baþka bir
		viable fonksiyon var ise her zaman o seçilir. variadic conversion en kötü dönüþüm.
	2-User-defined Conversion: Bu araç seti C dilinde yok CPP de daha öðrenmedik. Bu dönüþümler, dilin standartýnda olmayan
		fakat kullanýcýnýn bu dönüþümün yapýlabilmesi için oluþturduðu fonksiyona, derleyicinin bu fonksiyona çaðrý yaparak
		dönüþümün legal olmasýný saðlayan dönüþümlere denir. Variadik fonksiyona karþý kazanýyor, diðer dönüþümlere kaybediyor.

			struct Nec{ int x{}; };
			int main() {
				Nec mynec;
				mynec = 5; // fonksiyon yok ve bu sentaks hatasý
			}

			struct Nec{ 
				int x{}; 
				Nec(); 
				Nec(int); // fonksiyonu burada bildiriyoruz. Bu yazýlmaz ise Nec() fonksiyonu sentaks hatasýna sebep veriyor.
			};
			int main() {
				Nec mynec;
				mynec = 5; // artýk sentaks hatasý deðil çünkü derleyici struct içerisindeki fonksiyonu çaðýracak ve dönüþüm yapýlacak.
			}
	3-Standard Conversion: Dilin kurallarý gereði legal olan dönüþümler. Veri kaybýnýn olup olmamasý bu dönüþümün
		sorunu deðil. Burada legal olan, gerçekleþen tüm dönüþümler var.
		long double ==> char mesela burada dönüþüm var. Veri kaybý olmasý bu durumu deðiþtirmiyor.
		int ==> enum burada int türünden enum'a dönüþüm yok.
		enum ==> int türüne dönüþüm var.
		int* ==> double* türüne dönüþüm yok
		int* ==> void* türüne dönüþüm var
		void* ==> int* türüne ÖRTÜLÜ dönüþüm yok. Yukarýda olan dönüþümlerin hepsi ÖRTÜLÜ dönüþüm.
		int* ==> bool dönüþüm var. NULL ise 0, adres var ise 1

		Bir tane standart conversion olsaydý o seçilecekti. Birden fazla olursa ne olacak?

		void foo(double);
		void foo(int);
		void foo(unsigned int);
			Mesela burada 3 adet overload var ve çaðýrýlan ifadeye göre 3 adet standart conversion olabilir.

		Birden fazla std conversion olmasý durumunda fonksiyonu seçebilmek için üç kategoriye ayrýlýyor.
			-exact match: Ayný türden parametre deðiþkenleri olmasý durumu
			-promotion: Kendisinden daha yüksek öneme sahip bir deðiþkene promote edilmesi. short -> int
				int -> long vs.
			-standard conversion: En düþük öneme sahip. Exact match, promotion kategorilerine ait	
				en az bir tane deðiþken yok ise ve birden fazla standard conversion var ise ambiguity hatasý verecek

		1- Exact Match: Argümanla fonksiyonun parametresinin ayný tür olmasý.
			Ek olarak exact match olarak kabul edilen bazý durumlar var.
			a- fonksiyon parametresinin const, gönderilen argümanýn const olmamasý arasýnda yapýlan örtülü dönüþüm
				exact match kabul ediliyor.
				void foo(const int*);
				int main(){
					int x{};
					foo(&x); // gönderilen argüman int*, fonksiyon parametresi const int*. Burada örtülü dönüþüm var ama gene de exact match
				}
			
			b- Fonksiyon türünden, fonksiyon adresine türüne yapýlan dönüþümler exact match
				void foo(int (*)(int));
				int func(int);
				int main(void){
					foo(func); -> Burada function to pointer conversion olacak. Exact match
				}
			c- Array decay de exact match kabul ediliyor.
				void foo(int*);
				int main(){
					int ar[5]{};
					foo(ar); // array to pointer conversion var. Exact Match
				}
			d- L value referanstan R value referansa yapýlan conversionlar.
				void foo(int);
				int main(){
					int x{434};
					foo(x); // foo fonksiyonu l value ref istiyor ve biz ona l value yolladýk. Dönüþüm yok.
					foo(43); // R value referans yolladýk burada fonksiyonun parametresinin deðer kategorisini deðiþtirdik.
								// L value ref -> R value ref. Yapýlan bu dönüþüm exact match
				}
		2- Promotion: Ýki kategoriye ayrýlýyor. 
			a- integral promotion: int altý türlerden int türüne yapýlan conversionlar.
				- char 
				- unsigned char 
				- signed char 
				- short 
				- bool 
					türlerinden int türüne promotion var.

				void foo(int);
				void foo(double);
				int main(){
					foo('A'); // char türünden double türüne 'promotion' olmadýðý için int türüne promote edilecek.
								// eðer foo(int) olmasaydý conversion kýsmýnda iþleme alýnacaktý.
				}
			
			b- float türünden double türüne yapýlan promotion. Long double buna dahil deðil. Sadece flottan doublea
				void foo(long double);
				void foo(double);
				void foo(int);
				int main(){
					foo(3.5f); // float türünden int, double ve long double türüne CONVERSION var fakat
								// long double ve int türlerine promotion yok. Sadece double türüne promotion var.
				}
		
		3- Conversion: Eðer yukarýdaki kategorilerden hiçbiri yok ise standart conversion kullanýlýyor.
			Eðer birden fazla standart conversion var ise bu ambiguity hatasý. Promotion kýsmýndaki örnekte 
				birden fazla conversion var. float hem double, hem long double hem de int'e dönüþtürülebilir.
				Bu ambiguity hatasý verir.
			void foo(char);
			void foo(long double);
			void foo(double);
			void foo(int);
			int main(){
				// double parametreli fonksiyonu görmezden gel
				foo(3.4);  // sentaks hatasý verecek çünkü int, char ve double arasýnda conversion var.
				foo(3.4f); // floattan 3 türe conversion var. Sentaks hatasý, ambiguity

				// double parametreli fonksiyon eklendi
				foo(3.4); artýk sentaks hatasý deðil çünkü exact match var
				foo(3.4f); artýk sentaks hatasý deðil çünkü float -> double promotion var
			}
	
			void foo(unsigned int);
			void foo(long double);

			int main(){
				foo(12); // Argüman int türünden. int türünden unsigned int türüne yapýlan dönüþüm exact match olmadýðý
							için burada ambiguity var.
			}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ÖZEL DURUMLAR

1- const overloading: 
const olan ve olmayan nesneler için ayrý implementasyonlar yapýyoruz. Bunu yapmanýn en kolay yolu
	2 adet overload oluþturmak. const T* sadece read-only iken int* mutable yani yapýlan iþlemler çok farklý olacak.
void foo(int* param){
	std::cout << "Value of param: " << *param << std::endl;
}
void foo(const int* param){
	std::cout << "Value of param: " << *param << std::endl;
}

int main(void){
	const int x{45};
	int y{807685};

	foo(&x); // x const nesne ve const T* türünden T* türüne örtülü dönüþüm yok.
				// bundan dolayý foo(int*) fonksiyonu viable bile deðil. const int* parametreli fonksiyon çaðrýlacak.
	foo(&y); // burada her iki fonksiyonda viable olacak. Derleyici const olmayan parametreli fonksiyona
				// öncelik tanýdýðý için int* parametreli fonksiyon çaðrýlacak
 }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
2- Call by value ve call by reference olan fonksiyonlar: Bu overload þeklinin kullanýlmasýný önermiyorlar.

void bar(int);
void bar(int &);
void bar(const int &);
int main(){
	int x{};
	// const int& fonksiyonunu görmezden gel
	bar(x); // ambiguity, x bir l val reference. Hem int& hem de int ikisi de viable fonksiyon ve
				hangisinin seçileceðine dair bir kriter yok.
	bar(10); // 10 burada rvalue ref olduðu için int tarafýndan kullanýlacak

	//const int& fonksiyonu eklendi
	bar(10); // burada gene ambiguity oldu. const T& türlerine R value derleyicinin oluþturduðu
		temp val sayesinde kullanýlabiliyor. T ve const T& arasýnda ayrým yapan bir kural olmadýðý için
		ambiguity hatasý.
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
3- Parametrede varsayýlan argüman(default argument) olmasý

void foo(int, int = 0);
void foo(int);
int main(){
	foo(12); // default parametrenin olmasý ile ilk fonksiyon da viable oluyor. 
				// hangisinin seçileceðine dair bir kural olmadýðý için bu ambiguity.
}
1:37

